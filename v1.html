<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punch Blocks</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1a);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            color: #b9a6ff;
        }

        #score,
        #fps,
        #speedDisplay {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #score {
            top: 20px;
            left: 20px;
        }

        #fps {
            top: 20px;
            right: 20px;
        }

        #speedDisplay {
            bottom: 20px;
            left: 20px;
        }

        #controls {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
        }

        #alert,
        #tutorial {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            text-align: center;
        }

        #alert {
            top: 100px;
            color: #f99797;
        }

        #tutorial {
            top: 50px;
            color: white;
        }

        button {
            font-size: 14px;
            padding: 10px 20px;
            margin: 5px;
            background: #b9a6ff;
            color: #1a1a2e;
            border: none;
            cursor: pointer;
        }

        #startGame {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
        }

        canvas {
            display: none;
            margin: auto;
        }

        #videoCanvas {
            position: absolute;
            display: block;
            max-width: 640px;
            max-height: 480px;
            width: 100%;
            height: auto;
        }

        #gameCanvas {
            position: absolute;
            top: 150px;
            height: 80vh;
            width: 40vh;
            border: 5px solid #b9a6ff;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin: 10px;
        }

        #actionHistory {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 16px;
        }


        /* Debug panel */

        #debugPanel {
            position: absolute;
            background-color: #2d2d2d;
            border-radius: 4px;
            padding: 10px;
            top: 600px;
            /* well below main content */
            left: 10px;
        }

        .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .group {
            background-color: #383838;
            border-radius: 4px;
            padding: 5px;
            width: 48%;
        }

        .meter-container {
            position: relative;
            margin-top: 2px;
        }

        .meter {
            background-color: #555;
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            transition: width 0.3s ease, background-color 0.3s ease;
            width: 0;
        }

        .meter-target,
        .meter-peak {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
        }

        .meter-target {
            background-color: #ff0;
        }

        .meter-peak {
            background-color: #f0f;
        }

        .warning {
            color: #f44;
            font-weight: bold;
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            display: none;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            margin-right: 5px;
        }

        .status-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .value {
            font-weight: bold;
            cursor: pointer;
        }

        .value:hover {
            text-decoration: underline;
        }

        .plot-container {
            display: none;
            background-color: #444;
            padding: 5px;
            margin-top: 5px;
            border-radius: 3px;
        }

        .plot {
            width: 100%;
            height: 100px;
        }


        #configPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 320px;
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 15px;
            display: none;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .config-section {
            margin-bottom: 15px;
            background-color: #383838;
            border-radius: 6px;
            padding: 10px;
        }

        #configPanel h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #4CAF50;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }

        .config-item {
            margin-bottom: 10px;
        }

        #configPanel label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        #configPanel input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        #configPanel input[type="number"] {
            width: 60px;
            background-color: #2d2d2d;
            color: #b9a6ff;
            border: 1px solid #4CAF50;
            padding: 2px 5px;
            font-size: 12px;
        }

        #configPanel button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 5px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
        }

        #configPanel button:hover {
            background-color: #45a049;
        }

        #configPanel .default-value {
            font-size: 10px;
            color: #888;
            margin-left: 5px;
        }

        #configPanel .modified {
            color: #4CAF50;
        }
    </style>
</head>

<body>
    <div id="controls">
        <label for="smoothing">Smoothing Level:</label>
        <input type="range" id="smoothing" name="smoothing" min="1" max="10" value="5">
        <label for="minSpeedThreshold">Minimum Speed Threshold:</label>
        <input type="range" id="minSpeedThreshold" name="minSpeedThreshold" min="100" max="500" value="250">
        <label for="calibrationAttempts">Calibration Attempts:</label>
        <input type="range" id="calibrationAttempts" name="calibrationAttempts" min="1" max="5" value="3">
        <label for="calibrationCountdown">Calibration Countdown (s):</label>
        <input type="range" id="calibrationCountdown" name="calibrationCountdown" min="1" max="10" value="3">
        <label for="calibrationThresholdMultiplier">Calibration Threshold
            Multiplier (%):</label>
        <input type="range" id="calibrationThresholdMultiplier" name="calibrationThresholdMultiplier" min="50" max="100"
            value="90">
        <label for="jumpThreshold">Jump Height Threshold (%):</label>
        <input type="range" id="jumpThreshold" name="jumpThreshold" min="1" max="100" value="30">
        <label for="squatThreshold">Squat Height Threshold (%):</label>
        <input type="range" id="squatThreshold" name="squatThreshold" min="1" max="100" value="70">
        <button id="startCalibration">Start Calibration</button>
        <button id="restartCalibration">Restart Calibration</button>
        <button id="repeatStep">Repeat Step</button>
        <button id="toggleConfig">Toggle Config</button>
        <div id="configPanel">
            <div class="config-section">
                <h2>Calibration</h2>
                <div id="calibrationControls"></div>
            </div>
            <div class="config-section">
                <h2>Configuration</h2>
                <div id="configControls"></div>
            </div>
            <div class="config-section">
                <h2>Audio</h2>
                <div id="audioControls"></div>
            </div>
            <button id="saveConfig" disabled>Save</button>
            <button id="resetConfig">Reset</button>
            <button id="setCalibration">Set Example Calibration</button>
        </div>
    </div>
    <div id="fps">FPS: 0</div>
    <div id="alert"></div>
    <div id="tutorial"></div>
    <div id="speedDisplay"></div>
    <div id="actionHistory"></div>
    <canvas id="videoCanvas" width="640" height="480"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <button id="startGame" style="display:none;">Start Game</button>

    <div id="debugPanel">
        <div class="status-line">
            <h2>Debug Panel</h2>
            <span>Status: <span id="captureStatus" class="value"></span></span>
            <span>Last Action: <span id="lastAction" class="value"></span></span>
            <button id="toggleButton">Hide</button>
            <button id="pauseButton">Pause</button>
        </div>
        <div id="captureWarning" class="warning"></div>
        <div id="debugContent"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        class ConfigManager {
            constructor() {
                this.CONFIG = {
                    MIN_SPEED_THRESHOLD: { value: 1000, min: 500, max: 2000, step: 10, name: "Minimum Speed Threshold", order: 1 },
                    MIN_SPEED_THRESHOLD_HEAD: { value: 600, min: 300, max: 1200, step: 10, name: "Minimum Head Speed Threshold", order: 2 },
                    ATTEMPT_DURATION: { value: 2000, min: 1000, max: 5000, step: 100, name: "Attempt Duration (ms)", order: 3 },
                    CALIBRATION_ATTEMPTS: { value: 1, min: 1, max: 5, step: 1, name: "Number of Calibration Attempts", order: 4 },
                    CALIBRATION_COUNTDOWN: { value: 3, min: 1, max: 10, step: 1, name: "Calibration Countdown (seconds)", order: 5 },
                    CALIBRATION_THRESHOLD_MULTIPLIER: { value: 0.9, min: 0.5, max: 1.5, step: 0.1, name: "Calibration Threshold Multiplier", order: 6 },
                    SMOOTHING_LEVEL: { value: 5, min: 1, max: 10, step: 1, name: "Smoothing Level", order: 7 },
                    THRESHOLD_START_MULT: { value: 0.8, min: 0.5, max: 1, step: 0.1, name: "Threshold Start Multiplier", order: 8 },
                    THRESHOLD_END_MULT: { value: 0.8, min: 0.5, max: 1, step: 0.1, name: "Threshold End Multiplier", order: 9 },
                    TIME_WINDOW: { value: 100, min: 50, max: 200, step: 10, name: "Time Window", order: 10 },
                    DEBOUNCE_FRAMES: { value: 3, min: 1, max: 10, step: 1, name: "Debounce Frames", order: 11 },
                    HISTORY_SIZE: { value: 5, min: 3, max: 10, step: 1, name: "History Size", order: 12 },
                    MIN_MOVEMENT_THRESHOLD: { value: 0.001, min: 0.0001, max: 0.01, step: 0.0001, name: "Min Movement Threshold", order: 13 },
                    MAX_MOVEMENT_THRESHOLD: { value: 0.5, min: 0.1, max: 1, step: 0.1, name: "Max Movement Threshold", order: 14 },
                    MIN_TIME_THRESHOLD: { value: 1 / 120, min: 1 / 240, max: 1 / 60, step: 1 / 240, name: "Min Time Threshold", order: 15 },
                    ANOMALY_MULTIPLIER: { value: 3, min: 1, max: 5, step: 0.5, name: "Anomaly Multiplier", order: 16 },
                    WAIT_TIME: { value: 1000, min: 500, max: 2000, step: 100, name: "Wait Time", order: 17 }
                };
                this.CALIBRATION = {
                    LEFT_WRIST_THRESHOLD: { value: 0, min: 0, max: 2000, step: 10, name: "Left Wrist Threshold", order: 1 },
                    RIGHT_WRIST_THRESHOLD: { value: 0, min: 0, max: 2000, step: 10, name: "Right Wrist Threshold", order: 2 },
                    JUMP_THRESHOLD: { value: 0, min: 0, max: 2000, step: 10, name: "Jump Threshold", order: 3 },
                    JUMP_MAX_Y: { value: 0, min: 0, max: 1, step: 0.01, name: "Jump Max Y", order: 4 },
                    JUMP_MIN_Y: { value: 1, min: 0, max: 1, step: 0.01, name: "Jump Min Y", order: 5 },
                    SQUAT_THRESHOLD: { value: 0, min: 0, max: 2000, step: 10, name: "Squat Threshold", order: 6 },
                    SQUAT_MAX_Y: { value: 0, min: 0, max: 1, step: 0.01, name: "Squat Max Y", order: 7 },
                    SQUAT_MIN_Y: { value: 1, min: 0, max: 1, step: 0.01, name: "Squat Min Y", order: 8 }
                };
                this.AUDIO = {
                    MASTER_VOLUME: { value: 0.5, min: 0, max: 1, step: 0.1, name: "Master Volume", order: 1 },
                    MUSIC_VOLUME: { value: 0.5, min: 0, max: 1, step: 0.1, name: "Music Volume", order: 2 },
                    SFX_VOLUME: { value: 0.5, min: 0, max: 1, step: 0.1, name: "Sound Effects Volume", order: 3 }
                };
                this.isModified = false;
                this.lastCalibrationDate = null;
            }

            initUI() {
                this.createControls('calibrationControls', this.CALIBRATION);
                this.createControls('configControls', this.CONFIG);
                this.createControls('audioControls', this.AUDIO);
            }

            createControls(containerId, data) {
                const container = document.getElementById(containerId);
                const sortedEntries = Object.entries(data).sort((a, b) => a[1].order - b[1].order);
                for (const [key, item] of sortedEntries) {
                    const div = document.createElement('div');
                    div.className = 'config-item';
                    div.innerHTML = `
                        <label for="${key}">${item.name}:</label>
                        <input type="range" id="${key}" min="${item.min}" max="${item.max}" step="${item.step}" value="${item.value}">
                        <input type="number" id="${key}Value" value="${item.value}" min="${item.min}" max="${item.max}" step="${item.step}">
                        <span class="default-value" id="${key}Default">Default</span>
                    `;
                    container.appendChild(div);

                    const range = div.querySelector('input[type="range"]');
                    const number = div.querySelector('input[type="number"]');
                    const defaultSpan = div.querySelector('.default-value');

                    const updateValue = (value) => {
                        data[key].value = parseFloat(value);
                        range.value = value;
                        number.value = value;
                        this.checkModified(key, value, item.value, defaultSpan);
                    };

                    range.oninput = () => updateValue(range.value);
                    number.oninput = () => updateValue(number.value);

                    item.defaultValue = item.value;
                }
            }

            checkModified(key, currentValue, defaultValue, defaultSpan) {
                if (currentValue != defaultValue) {
                    defaultSpan.textContent = 'Modified';
                    defaultSpan.classList.add('modified');
                    this.isModified = true;
                } else {
                    defaultSpan.textContent = 'Default';
                    defaultSpan.classList.remove('modified');
                }
                document.getElementById('saveConfig').disabled = !this.isModified;
            }

            saveConfig() {
                localStorage.setItem('configData', JSON.stringify({
                    CONFIG: this.CONFIG,
                    CALIBRATION: this.CALIBRATION,
                    AUDIO: this.AUDIO,
                    lastCalibrationDate: this.lastCalibrationDate
                }));
                this.isModified = false;
                document.getElementById('saveConfig').disabled = true;
                console.log('Configuration saved');
            }

            loadConfig() {
                const savedConfig = localStorage.getItem('configData');
                if (savedConfig) {
                    const parsedConfig = JSON.parse(savedConfig);
                    this.CONFIG = parsedConfig.CONFIG;
                    this.CALIBRATION = parsedConfig.CALIBRATION;
                    this.AUDIO = parsedConfig.AUDIO;
                    this.lastCalibrationDate = parsedConfig.lastCalibrationDate;
                    this.updateUI();
                    console.log('Configuration loaded');
                }
            }

            resetConfig() {
                for (const section of [this.CONFIG, this.CALIBRATION, this.AUDIO]) {
                    for (const key in section) {
                        section[key].value = section[key].defaultValue;
                    }
                }
                this.lastCalibrationDate = null;
                this.updateUI();
                this.isModified = false;
                document.getElementById('saveConfig').disabled = true;
                console.log('Configuration reset to defaults');
            }

            updateUI() {
                for (const section of [this.CONFIG, this.CALIBRATION, this.AUDIO]) {
                    for (const [key, item] of Object.entries(section)) {
                        const range = document.getElementById(key);
                        const number = document.getElementById(`${key}Value`);
                        const defaultSpan = document.getElementById(`${key}Default`);
                        if (range && number && defaultSpan) {
                            range.value = item.value;
                            number.value = item.value;
                            this.checkModified(key, item.value, item.defaultValue, defaultSpan);
                        }
                    }
                }
            }

            setExampleCalibration() {
                const exampleData = {
                    LEFT_WRIST_THRESHOLD: 1200,
                    RIGHT_WRIST_THRESHOLD: 1100,
                    JUMP_THRESHOLD: 900,
                    JUMP_MAX_Y: 0.8,
                    JUMP_MIN_Y: 0.2,
                    SQUAT_THRESHOLD: 800,
                    SQUAT_MAX_Y: 0.9,
                    SQUAT_MIN_Y: 0.3
                };
                for (const [key, value] of Object.entries(exampleData)) {
                    if (this.CALIBRATION[key]) {
                        this.CALIBRATION[key].value = value;
                    }
                }
                this.lastCalibrationDate = new Date().toISOString();
                this.updateUI();
                this.isModified = true;
                document.getElementById('saveConfig').disabled = false;
                console.log('Example calibration data set');
            }

            needsCalibration() {
                if (!this.lastCalibrationDate) return true;
                const daysSinceCalibration = (new Date() - new Date(this.lastCalibrationDate)) / (1000 * 60 * 60 * 24);
                return daysSinceCalibration > 7;
            }

            getValue(section, key) {
                return this[section][key].value;
            }

            setValue(section, key, value) {
                if (this[section][key]) {
                    this[section][key].value = parseFloat(value);
                    const range = document.getElementById(key);
                    const number = document.getElementById(`${key}Value`);
                    const defaultSpan = document.getElementById(`${key}Default`);
                    if (range) range.value = value;
                    if (number) number.value = value;
                    if (defaultSpan) this.checkModified(key, value, this[section][key].defaultValue, defaultSpan);
                    console.log(`Set ${section}.${key} to ${value}`);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const configManager = new ConfigManager();
            const toggleButton = document.getElementById('toggleConfig');
            const configPanel = document.getElementById('configPanel');
            const saveButton = document.getElementById('saveConfig');
            const resetButton = document.getElementById('resetConfig');
            const setCalibrationButton = document.getElementById('setCalibration');

            configManager.initUI();
            configManager.loadConfig();

            toggleButton.addEventListener('click', function () {
                configPanel.style.display = configPanel.style.display === 'none' ? 'block' : 'none';
                console.log(`Config panel ${configPanel.style.display === 'none' ? 'hidden' : 'shown'}`);
            });

            saveButton.addEventListener('click', function () {
                configManager.saveConfig();
            });

            resetButton.addEventListener('click', function () {
                configManager.resetConfig();
            });

            setCalibrationButton.addEventListener('click', function () {
                configManager.setExampleCalibration();
            });

            console.log('ConfigManager initialized');
        });

    </script>

    <script>
        // DEBUG PANEL
        // This is primarily to help in figuring out the calibration system.
        // It may be removed and disabled in the future. 

        class DebugPanel {
            constructor() {
                this.data = {
                    captureStatus: '',
                    captureWarning: '',
                    lastAction: '',
                    actions: {
                        rightWrist: { speed: 0, target: 1000, peak: 0 },
                        leftWrist: { speed: 0, target: 1000, peak: 0 },
                        jump: { speed: 0, speedTarget: 1000, y: 0, yTarget: 300, yPeak: 0 },
                        squat: { speed: 0, speedTarget: 1000, y: 0, yTarget: 300, yPeak: 0 }
                    }
                };
                this.lastUpdate = Date.now();
                this.lastPeakClear = Date.now();
                this.peakClearInterval = 10000; // Clear peaks every 10 seconds
                this.maxVal = 2000; // Good enough for most purposes
                this.isVisible = true;
                this.isPaused = false;
                this.plotData = {};
                this.maxPlotPoints = 100;

                this.initElements();
                this.createActionGroups();
                this.initEventListeners();
            }

            initElements() {
                this.elements = {
                    captureStatus: document.getElementById('captureStatus'),
                    captureWarning: document.getElementById('captureWarning'),
                    lastAction: document.getElementById('lastAction'),
                    toggleButton: document.getElementById('toggleButton'),
                    pauseButton: document.getElementById('pauseButton'),
                    debugContent: document.getElementById('debugContent')
                };
            }

            createActionGroups() {
                const content = document.createDocumentFragment();
                let row;
                Object.keys(this.data.actions).forEach((action, index) => {
                    if (index % 2 === 0) {
                        row = document.createElement('div');
                        row.className = 'row';
                        content.appendChild(row);
                    }
                    const group = this.createActionGroup(action);
                    row.appendChild(group);
                });
                this.elements.debugContent.appendChild(content);
            }

            createActionGroup(action) {
                const group = document.createElement('div');
                group.className = 'group';
                group.innerHTML = `
                    <h3>${action.charAt(0).toUpperCase() + action.slice(1)}</h3>
                    <div>Speed: <span id="${action}Speed" class="value" onclick="debugPanel.togglePlot('${action}', 'speed')"></span> / <span id="${action}Target"></span></div>
                    <div>Peak: <span id="${action}Peak" class="value" onclick="debugPanel.togglePlot('${action}', 'peak')"></span></div>
                    <div class="meter-container">
                        <div class="meter">
                            <div id="${action}Meter" class="meter-fill"></div>
                        </div>
                        <div id="${action}TargetMark" class="meter-target"></div>
                        <div id="${action}PeakMark" class="meter-peak"></div>
                    </div>
                    <div id="${action}SpeedPlot" class="plot-container">
                        <canvas class="plot"></canvas>
                    </div>
                    <div id="${action}PeakPlot" class="plot-container">
                        <canvas class="plot"></canvas>
                    </div>
                    ${!action.includes('Wrist') ? `
                        <div>Y: <span id="${action}Y" class="value" onclick="debugPanel.togglePlot('${action}', 'y')"></span> / <span id="${action}YTarget"></span></div>
                        <div>Y Peak: <span id="${action}YPeak" class="value" onclick="debugPanel.togglePlot('${action}', 'yPeak')"></span></div>
                        <div class="meter-container">
                            <div class="meter">
                                <div id="${action}YMeter" class="meter-fill"></div>
                            </div>
                            <div id="${action}YTargetMark" class="meter-target"></div>
                            <div id="${action}YPeakMark" class="meter-peak"></div>
                        </div>
                        <div id="${action}YPlot" class="plot-container">
                            <canvas class="plot"></canvas>
                        </div>
                        <div id="${action}YPeakPlot" class="plot-container">
                            <canvas class="plot"></canvas>
                        </div>
                    ` : ''}
                `;
                return group;
            }

            initEventListeners() {
                this.elements.toggleButton.addEventListener('click', () => this.toggleVisibility());
                this.elements.pauseButton.addEventListener('click', () => this.togglePause());
            }

            setCaptureStatus(status) {
                if (this.isPaused) return;
                this.data.captureStatus = status;
            }

            setCaptureWarning(warning) {
                if (this.isPaused) return;
                this.data.captureWarning = warning;
                this.elements.captureWarning.style.display = warning ? 'block' : 'none';
            }

            setLastAction(action) {
                if (this.isPaused) return;
                this.data.lastAction = action;
            }

            setActionData(action, data) {
                if (this.isPaused) return;
                const currentData = this.data.actions[action];
                this.data.actions[action] = { ...currentData, ...data };

                if ((data.speed ?? 0) > (currentData.peak ?? 0)) {
                    this.data.actions[action].peak = data.speed;
                }

                if ((data.y ?? 0) > (currentData.yPeak ?? 0)) {
                    this.data.actions[action].yPeak = data.y;
                }

                // Update plot data
                Object.keys(data).forEach(key => {
                    const plotKey = `${action}_${key}`;
                    if (!this.plotData[plotKey]) {
                        this.plotData[plotKey] = [];
                    }
                    this.plotData[plotKey].push(data[key]);
                    if (this.plotData[plotKey].length > this.maxPlotPoints) {
                        this.plotData[plotKey].shift();
                    }
                });
            }

            clearPeaks() {
                Object.keys(this.data.actions).forEach(action => {
                    this.data.actions[action].peak = 0;
                    if (this.data.actions[action].yPeak !== undefined) {
                        this.data.actions[action].yPeak = 0;
                    }
                });
            }

            toggleVisibility() {
                this.isVisible = !this.isVisible;
                this.elements.debugContent.style.display = this.isVisible ? 'block' : 'none';
                this.elements.toggleButton.textContent = this.isVisible ? 'Hide' : 'Show';
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                this.elements.pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
            }

            togglePlot(action, type) {
                const plotContainer = document.getElementById(`${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot`);
                if (plotContainer.style.display === 'none' || plotContainer.style.display === '') {
                    plotContainer.style.display = 'block';
                    this.updatePlot(action, type);
                } else {
                    plotContainer.style.display = 'none';
                }
            }

            updatePlot(action, type) {
                const plotKey = `${action}_${type}`;
                const canvas = document.querySelector(`#${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot canvas`);
                const ctx = canvas.getContext('2d');
                const data = this.plotData[plotKey];

                if (!data || data.length === 0) return;

                const width = canvas.width;
                const height = canvas.height;
                const max = Math.max(...data);
                const min = Math.min(...data);

                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;

                data.forEach((value, index) => {
                    const x = (index / (data.length - 1)) * width;
                    const y = height - ((value - min) / (max - min)) * height;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();
            }

            updateDOM() {
                if (!this.isVisible) return;
                const now = Date.now();
                if (now - this.lastUpdate < 100) return;
                this.lastUpdate = now;

                if (now - this.lastPeakClear >= this.peakClearInterval) {
                    this.clearPeaks();
                    this.lastPeakClear = now;
                }

                this.elements.captureStatus.textContent = this.data.captureStatus;
                this.elements.captureWarning.textContent = this.data.captureWarning;
                this.elements.lastAction.textContent = this.data.lastAction;

                Object.entries(this.data.actions).forEach(([action, data]) => {
                    this.updateActionInfo(action, data);
                });
            }

            updateActionInfo(action, data) {
                const speed = document.getElementById(`${action}Speed`);
                const target = document.getElementById(`${action}Target`);
                const peak = document.getElementById(`${action}Peak`);
                const meter = document.getElementById(`${action}Meter`);
                const targetMark = document.getElementById(`${action}TargetMark`);
                const peakMark = document.getElementById(`${action}PeakMark`);

                if (speed) speed.textContent = (data.speed ?? 0).toFixed(2);
                if (target) target.textContent = ((data.target ?? data.speedTarget) ?? 0).toFixed(2);
                if (peak) peak.textContent = (data.peak ?? 0).toFixed(2);

                this.updateMeter(
                    meter,
                    targetMark,
                    peakMark,
                    data.speed ?? 0,
                    (data.target ?? data.speedTarget) ?? 0,
                    data.peak ?? 0
                );

                if (!action.includes('Wrist')) {
                    const yValue = document.getElementById(`${action}Y`);
                    const yTarget = document.getElementById(`${action}YTarget`);
                    const yPeak = document.getElementById(`${action}YPeak`);
                    const yMeter = document.getElementById(`${action}YMeter`);
                    const yTargetMark = document.getElementById(`${action}YTargetMark`);
                    const yPeakMark = document.getElementById(`${action}YPeakMark`);

                    if (yValue) yValue.textContent = (data.y ?? 0).toFixed(2);
                    if (yTarget) yTarget.textContent = (data.yTarget ?? 0).toFixed(2);
                    if (yPeak) yPeak.textContent = (data.yPeak ?? 0).toFixed(2);

                    this.updateMeter(
                        yMeter,
                        yTargetMark,
                        yPeakMark,
                        data.y ?? 0,
                        data.yTarget ?? 0,
                        data.yPeak ?? 0
                    );
                }

                // Update plots if they are visible
                ['speed', 'peak', 'y', 'yPeak'].forEach(type => {
                    const plotContainer = document.getElementById(`${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot`);
                    if (plotContainer && plotContainer.style.display !== 'none') {
                        this.updatePlot(action, type);
                    }
                });
            }

            updateMeter(meter, targetMark, peakMark, value, target, peak) {
                if (!meter || !targetMark || !peakMark) return;

                const maxVal = this.maxVal; // This should come from CONFIG or something
                const percentage = Math.min(Math.max(((value ?? 0) / maxVal) * 100, 0), 100);
                const targetPercentage = Math.min(Math.max(((target ?? 0) / maxVal) * 100, 0), 100);
                const peakPercentage = Math.min(Math.max(((peak ?? 0) / maxVal) * 100, 0), 100);

                meter.style.width = `${percentage}%`;
                targetMark.style.left = `${targetPercentage}%`;
                peakMark.style.left = `${peakPercentage}%`;

                const diff = Math.abs((value ?? 0) - (target ?? 0));
                meter.style.backgroundColor = diff <= 10 ? '#4CAF50' : diff <= 20 ? '#FFA500' : '#FF4444';
            }
        }


    </script>
    <script>

        // TODO Cross Origin Isolation will improve the timing accuracy fom 100us to 5us
        // timing accuracy is greatly needed for speed measurment

        // I think I can do that with s3 bucket headers???

        // Conceptual design
        // 1. Input from mediaPipe (onResults)
        // 2. Speed calculation for landmarks using history, EMA, and anomaly detection
        // 3. (Landmark speeds go into debugPanel, which is not normally displayed)
        // 4. In calibration mode only, these speeds are used to set thresholds that go into landmarkInfo
        // 5. In practice mode, the speeds are compared to the thresholds, but not used for anything
        // 6. In game mode:
        //   a. Debouncing -- multiple copies of the same input are ignored
        //   b. Fed into game logic as a keyboard input (left, right, h for hard drop) 
        // Each component shares minimal data. For example the calibration data history is totally separate 
        // from the speed calculation history.

        // The main steps are:
        // 1. Nothing, welcome screen
        // 2. Enable camera
        // 3. Calibration
        // 4. Practice
        // 5. Play game

        // The calibration phases are:
        // For each action:
        //    For each attempt:
        //        (If not first attempt) wait 3 seconds. Display a countdown. 
        //        Measure peak speed and min, max Y of the action
        //    Average the 3 attempts and save it in the landmarkInfo data



        // Constants and Configuration
        let CONFIG = {
            MIN_SPEED_THRESHOLD: 1000,
            MIN_SPEED_THRESHOLD_HEAD: 600,
            ATTEMPT_DURATION: 2000,
            CALIBRATION_ATTEMPTS: 1, // 3,
            CALIBRATION_COUNTDOWN: 3,
            CALIBRATION_THRESHOLD_MULTIPLIER: 0.9,
            TIME_WINDOW: 100,
            DEBOUNCE_FRAMES: 1,
            // These are new and don't all have controls yet
            SMOOTHING_LEVEL: 5,
            HISTORY_SIZE: 5,
            MIN_MOVEMENT_THRESHOLD: 0.001, // 0.1% of canvas width
            MAX_MOVEMENT_THRESHOLD: 0.5,   // 50% of canvas width
            MIN_TIME_THRESHOLD: 1 / 120,   // Assuming max 120 FPS
            ANOMALY_MULTIPLIER: 3,         // For dynamic anomaly detection
            WAIT_TIME: 1000,               // 3 seconds
            THRESHOLD_START_MULT: 0.8,
            THRESHOLD_END_MULT: 0.3
        };

        // Global Variables
        const videoElement = document.createElement('video');
        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');
        const gameCanvas = document.getElementById('gameCanvas');
        const gl = gameCanvas.getContext('webgl');
        const scoreElement = document.getElementById('score');
        const fpsDisplay = document.getElementById('fps');
        const alertDisplay = document.getElementById('alert');
        const tutorialDisplay = document.getElementById('tutorial');
        const speedDisplay = document.getElementById('speedDisplay');
        const actionHistoryDisplay = document.getElementById('actionHistory');

        let isGameRunning = false;
        let lastTimestamp = performance.now();
        let fps = 0;
        let fpsHistory = [];
        const FPS_AVERAGE_COUNT = 10;

        let latestInput = null;
        let actionHistory = [];
        const MAX_HISTORY = 5;


        const debugPanel = new DebugPanel();
        debugPanel.setCaptureStatus('Active');

        const configPanel = new ConfigManager();
        const toggleButton = document.getElementById('toggleConfig');
        const configPanelCntr = document.getElementById('configPanel');
        const saveButton = document.getElementById('saveConfig');
        const resetButton = document.getElementById('resetConfig');
        const setCalibrationButton = document.getElementById('setCalibration');
        configPanel.initUI();
        toggleButton.addEventListener('click', function () {
            configPanelCntr.style.display = configPanelCntr.style.display === 'none' ? 'block' : 'none';
            console.log(`Config panel ${configPanelCntr.style.display === 'none' ? 'hidden' : 'shown'}`);
        });

        saveButton.addEventListener('click', function () {
            configPanel.saveConfig();
        });

        resetButton.addEventListener('click', function () {
            configPanel.resetConfig();
        });

        setCalibrationButton.addEventListener('click', function () {
            configPanel.setExampleCalibration();
        });
        configPanel.loadConfig();

        // Landmark Configuration
        // This is constant configuration. It's just which landmarks we should care
        // continue processing. If a landmark isn't in here it is completely ignored.
        const landmarkConfig = {
            leftWrist: { index: 15, color: 'red' },
            rightWrist: { index: 16, color: 'green' },
            nose: { index: 0, color: 'blue' }
        };

        // This is used for the calibration/practice state machine. 
        // It isn't really used for the game itself. 
        // The gameState opject is totally rewritten in each step. This is just an example I guess.
        let visState = {}

        function resetVisState() {
            visState = {
                phase: 'start', // 'idle', 'calibration', 'practice', 'game', 'pause', 'end'
                step: 'leftWrist', // leftWrist, rightWrist, jump, squat
                attempts: [], // maximum config.CALIBRATION_ATTEMPTS attempts 
                lastAttemptTime: 0, // After attempt 1, wait 1 second before next attempt
                lastCountdownTime: 0,
                startTime: 0,
                maxTime: 30000, // 30 seconds max per step
                frameCount: 0,
                waitForCalibration: false,
                alertText: '',
                alertTime: 0,
                // Used in Calibration mode 
                currentAttemptData: {
                    maxSpeed: 0,
                    startTime: 0,
                    maxY: 0,
                    minY: 0
                },
                // Used in Practice mode and Game mode
                currentMotionData: {
                    engaged: false,
                    action: '',
                    maxSpeed: 0,
                    maxY: 0,
                    minY: 0
                }
            };
        }

        resetVisState();

        // Debounce System
        let debounceCounters = { l: 0, r: 0, u: 0, h: 0, n: 0 };

        function resetDebounceCounters() {
            Object.keys(debounceCounters).forEach(key => debounceCounters[key] = 0);
        }

        function debounceInput(input) {
            // Not sure if this actually works well enough TODO
            let mult = (input === 'h' || input === 'u') ? 2 : 1;
            let frames = configPanel.getValue('CONFIG', 'DEBOUNCE_FRAMES');
            if (input) {
                debounceCounters[input]++;
                if (debounceCounters[input] >= (frames * mult)) {
                    sendInput(input);
                    resetDebounceCounters();
                }
            } else {
                resetDebounceCounters();
            }
        }

        function sendInput(input) {
            if (latestInput === null) latestInput = input;
        }

        // Calibration Functions
        function startCalibration() {
            isGameRunning = false;
            document.getElementById('videoCanvas').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'none';

            resetVisState();
            visState.phase = 'calibration';
            visState.step = 'leftWrist';
            visState.countdown = configPanel.getValue('CONFIG', 'CALIBRATION_COUNTDOWN');
            visState.lastCountdownTime = performance.now();
            visState.startTime = performance.now();
            visState.frameCount = 0;

            updateCalibrationDisplay();
        }













        function updateCalibration(landmark, speed) {
            if (visState.waitForCalibration) return;

            const threshold = (visState.step === 'jump' || visState.step === 'squat')
                ? configPanel.getValue('CONFIG', 'MIN_SPEED_THRESHOLD_HEAD')
                : configPanel.getValue('CONFIG', 'MIN_SPEED_THRESHOLD');

            const currentTime = performance.now();

            // Start a new attempt if we haven't started one yet
            if (visState.currentAttemptData.startTime === 0 && speed >= threshold) {
                visState.currentAttemptData = {
                    maxSpeed: speed,
                    startTime: currentTime,
                    maxY: landmark.y,
                    minY: landmark.y
                };
                console.log("Started new calibration attempt for", visState.step);
            }

            // Update attempt data if we're in the middle of an attempt
            if (visState.currentAttemptData.startTime !== 0) {
                visState.currentAttemptData.maxSpeed = Math.max(visState.currentAttemptData.maxSpeed, speed);

                if (visState.step === 'jump' || visState.step === 'squat') {
                    visState.currentAttemptData.maxY = Math.max(visState.currentAttemptData.maxY, landmark.y);
                    visState.currentAttemptData.minY = Math.min(visState.currentAttemptData.minY, landmark.y);
                }

                if (currentTime - visState.currentAttemptData.startTime >= configPanel.getValue('CONFIG', 'ATTEMPT_DURATION')) {
                    finishCalibrationAttempt();
                }
            }


            debugPanel.setActionData(visState.step, {
                speed: speed,
                threshold: threshold
            });
            debugPanel.updateDOM();
        }















        function finishCalibrationAttempt() {
            console.log("Finished calibration attempt for", visState.step, "Max speed:", visState.currentAttemptData.maxSpeed);

            visState.attempts.push(visState.currentAttemptData.maxSpeed);

            if (visState.step === 'jump' || visState.step === 'squat') {
                // TODO should be the min, max for any attempt, not for the last only
                configPanel.setValue('CALIBRATION', 'JUMP_MAX_Y', visState.currentAttemptData.maxY);
                configPanel.setValue('CALIBRATION', 'SQUAT_MIN_Y', visState.currentAttemptData.minY);
            }

            visState.lastAttemptTime = performance.now();
            visState.waitForCalibration = true;
            visState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };

        }

        function setThreshold(action, value) {
            if (action === 'LeftWrist') {
                configPanel.setValue('CALIBRATION', 'LEFT_WRIST_THRESHOLD', value);
            } else if (action === 'RightWrist') {
                configPanel.setValue('CALIBRATION', 'RIGHT_WRIST_THRESHOLD', value);
            } else if (action === 'Jump') {
                configPanel.setValue('CALIBRATION', 'JUMP_THRESHOLD', value);
            } else if (action === 'Squat') {
                configPanel.setValue('CALIBRATION', 'SQUAT_THRESHOLD', value);
            }
        }

        function getThreshold(action) {
            if (action === 'LeftWrist') {
                return configPanel.getValue('CALIBRATION', 'LEFT_WRIST_THRESHOLD');
            } else if (action === 'RightWrist') {
                return configPanel.getValue('CALIBRATION', 'RIGHT_WRIST_THRESHOLD');
            } else if (action === 'Jump') {
                return configPanel.getValue('CALIBRATION', 'JUMP_THRESHOLD');
            } else if (action === 'Squat') {
                return configPanel.getValue('CALIBRATION', 'SQUAT_THRESHOLD');
            }
        }

        function getMinY(action) {
            if (action === 'Jump') {
                return configPanel.getValue('CALIBRATION', 'JUMP_MIN_Y');
            } else if (action === 'Squat') {
                return configPanel.getValue('CALIBRATION', 'SQUAT_MIN_Y');
            }
        }

        function getMaxY(action) {
            if (action === 'Jump') {
                return configPanel.getValue('CALIBRATION', 'JUMP_MAX_Y');
            } else if (action === 'Squat') {
                return configPanel.getValue('CALIBRATION', 'SQUAT_MAX_Y');
            }
        }

        function finishCalibrationStep() {
            const avgSpeed = visState.attempts.reduce((a, b) => a + b, 0) / visState.attempts.length;
            const mult = configPanel.getValue('CALIBRATION','CALIBRATION_THRESHOLD_MULTIPLIER')
            setThreshold(visState.step, avgSpeed * mult);
            // Should we have different multipliers for different actions?
            debugPanel.setActionData(visState.step, { target: avgSpeed * mult });
            visState.attempts = [];
            visState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };
        }









        function finishCalibration() {
            visState.phase = 'practice';
            startPracticeStage();
        }

        function restartCalibrationStep() {
            visState.attempts = [];
            visState.countdown = configPanel.getValue('CALIBRATION', 'CALIBRATION_COUNTDOWN');
            visState.startTime = performance.now();
            updateCalibrationDisplay();
        }

        function updateCalibrationDisplay() {
            if (visState.phase === 'game') {
                tutorialDisplay.textContent = "Running";
                return;
            }
            if (visState.phase === 'calibration') {
                const stepName = visState.step.charAt(0).toUpperCase() + visState.step.slice(1);
                if (visState.waitForCalibration) {
                    tutorialDisplay.textContent = `Calibrating ${stepName}: Wait for next attempt`;
                } else {
                    tutorialDisplay.textContent = `Calibrating ${stepName}: Perform action ${visState.attempts.length + 1}/${configPanel.getValue('CONFIG','CALIBRATION_ATTEMPTS')}`;
                }
            }
        }

        // Practice Stage Functions
        // Everything here needs to be rewritten
        // Currently Unused
        function startPracticeStage() {
            isGameRunning = false;
            document.getElementById('videoCanvas').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'none';

            resetVisState();
            visState = {
                phase: 'practice',
                step: 'leftWrist',
                startTime: performance.now(),
                maxTime: 60000, // 60 seconds for entire practice
                frameCount: 0
            };
            updatePracticeDisplay();
        }

        function updatePractice(step, landmark, speed) {
            if (performance.now() - visState.startTime > visState.maxTime) {
                finishPractice();
                return;
            }

            const threshold = getThreshold(step);
            const percentOfThreshold = (speed / threshold) * 100;

            if (speed >= threshold) {
                showSuccess(`Great job! ${speed.toFixed(0)} speed (${percentOfThreshold.toFixed(0)}% of threshold)`);
                visState.completed.push(step);
                moveToNextPracticeStep();
            } else if (speed >= configPanel.getValue('CONFIG','MIN_SPEED_THRESHOLD')) {
                showWarning(`Close! ${speed.toFixed(0)} speed (${percentOfThreshold.toFixed(0)}% of threshold). Try again!`);
            }
            updatePracticeDisplay();
        }

        function moveToNextPracticeStep() {
            switch (visState.step) {
                case 'leftWrist': visState.step = 'rightWrist'; break;
                case 'rightWrist': visState.step = 'jump'; break;
                case 'jump': visState.step = 'squat'; break;
                case 'squat': finishPractice(); return;
            }
            updatePracticeDisplay();
        }

        function finishPractice() {
            visState.phase = 'ready';
            document.getElementById('startGame').style.display = 'block';
            tutorialDisplay.textContent = "Great job! You're ready to play!";
            alertDisplay.textContent = "Click 'Start Game' when you're ready.";
        }

        function updatePracticeDisplay() {
            const stepName = visState.step.charAt(0).toUpperCase() + visState.step.slice(1);
            tutorialDisplay.textContent = `Practice ${stepName}`;
            alertDisplay.textContent = `Completed: ${visState.completed.join(', ')}`;
        }

        // TODO use the visState.alert to display messages
        function showWarning(message) {
            alertDisplay.textContent = message;
            alertDisplay.style.color = '#ffaa00';
            setTimeout(() => {
                alertDisplay.style.color = '#f99797';
            }, 2000);
        }

        function showSuccess(message) {
            alertDisplay.textContent = message;
            alertDisplay.style.color = '#00ff00';
            setTimeout(() => {
                alertDisplay.style.color = '#f99797';
            }, 2000);
        }

        // Video Processing and Pose Detection
        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/${file}`
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        let camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });

        camera.start();
        console.log("Camera started")

        function onResults(results) {
            updateFPS();
            debugPanel.updateDOM(); // Probably shouldn't do this every frame
            drawVideoFrame(results);

            for (const [name, config] of Object.entries(landmarkConfig)) {
                if (config.index !== undefined) {  // Only process landmarks with defined indices
                    if (landmarkConfig[name]) {
                        if (results.poseLandmarks === undefined) continue;
                        // Could add a warning if no landmarks are visible
                        const landmark = results.poseLandmarks[config.index];
                        if (landmark.visibility < 0.75) continue;

                        // calculateSpeed is stateful since it does smoothing and anomaly detection
                        const speed = calculateSpeed(landmark, name);

                        // This manages the game state. Sets the calibration step, attempts, practice mode, or game mode. 

                        updateVisState();
                        if (visState.phase == 'start' && (name == "leftWrist" || name == "rightWrist" || name == "nose")) {
                            // For the wrist landmarks, we can display debug data right away 
                            // For the nose, we need to know if it is a squat or a jump, which requires calibration
                            // to be complete
                            displayName = name;
                            if (displayName === "nose") displayName = "jump";
                            debugPanel.setActionData(displayName, { speed: speed });
                        }
                        else if (visState.phase === 'calibration' && (name == visState.step || name == 'nose' && visState.step == 'jump' || name == 'nose' && visState.step == 'squat')) {
                            // Update the actual calibration data. 
                            updateCalibration(landmark, speed);
                            updateCalibrationDisplay(); // This call does not seem to be working right now. Separate call in updateGameStep needed. Why?
                        } else if (visState.phase === 'practice') {
                            updatePractice(name, landmark, speed);
                        } else if (visState.phase === 'game') {
                            processLandmark(landmark, name, speed);
                        }

                    }
                }
            }
            visState.frameCount++;
        }

        // This should be the only place the vis state machine is updated. 
        // TODO : Get practice working, add a countdown before game start
        // add some kind of pause functionality, fix updateCalbrationDisplay
        function updateVisState() {
            switch (visState.phase) {
                case 'start': break; // User has to click to start 
                case 'calibration':
                    switch (visState.step) {
                        case 'leftWrist':
                            if (visState.attempts.length > 0 && (performance.now() - visState.lastAttemptTime) < configPanel.getValue('CONFIG','WAIT_TIME')) {
                                visState.waitForCalibration = true;
                            } else if (visState.attempts.length === configPanel.getValue('CONFIG','CALIBRATION_ATTEMPTS')) {
                                visState.waitForCalibration = false;
                                finishCalibrationStep();
                                resetVisState();
                                visState.phase = 'calibration';
                                visState.step = 'rightWrist';
                                updateCalibrationDisplay();
                            } else {
                                visState.waitForCalibration = false;
                            }
                            break;
                        case 'rightWrist':
                            if (visState.attempts.length > 0 && (performance.now() - visState.lastAttemptTime) < configPanel.getValue('CONFIG','WAIT_TIME')) {
                                visState.waitForCalibration = true;
                            } else if (visState.attempts.length === config.getValue('CALIBRATION','CALIBRATION_ATTEMPTS')) {
                                visState.waitForCalibration = false;
                                finishCalibrationStep();
                                resetVisState();
                                visState.phase = 'calibration';
                                visState.step = 'jump';
                                updateCalibrationDisplay();
                            } else {
                                visState.waitForCalibration = false;
                            }
                            break;
                        case 'jump':
                            if (visState.attempts.length > 0 && (performance.now() - visState.lastAttemptTime) < configPanel.getValue('CONFIG','WAIT_TIME')) {
                                visState.waitForCalibration = true;
                            } else if (visState.attempts.length === configPanel.getValue('CALIBRATION','CALIBRATION_ATTEMPTS')) {
                                visState.waitForCalibration = false;
                                finishCalibrationStep();
                                resetVisState();
                                visState.phase = 'calibration';
                                visState.step = 'squat';
                                updateCalibrationDisplay();
                            } else {
                                visState.waitForCalibration = false;
                            }
                            break;
                        case 'squat':
                            if (visState.attempts.length > 0 && (performance.now() - visState.lastAttemptTime) < configPanel.getValue('CONFIG','WAIT_TIME')) {
                                visState.waitForCalibration = true;
                            } else if (visState.attempts.length === configPanel.getValue('CALIBRATION','CALIBRATION_ATTEMPTS')) {
                                resetVisState();
                                visState.phase = 'game'; // Add a countdown here
                                updateCalibrationDisplay();
                                startGame();
                            } else {
                                visState.waitForCalibration = false;
                            }
                            break;
                    }
                    break;
                case 'practice': break;
                case 'game': break;
            }
        }

        // Not used to make debugging a bit easier
        // Will add back in later
        function validateResults(results) {
            if (!results.poseLandmarks || results.poseLandmarks.length < 17) {
                handleErrorState(1, "Pose landmarks not detected");
                return false;
            }

            const requiredLandmarks = [0, 11, 12, 13, 14, 15, 16].map(i => results.poseLandmarks[i]);
            if (!areLandmarksVisible(requiredLandmarks)) {
                handleErrorState(2, "Please step back");
                return false;
            }

            return true;
        }

        function areLandmarksVisible(landmarks) {
            return landmarks.every(landmark => landmark && landmark.visibility > 0.75);
        }

        function processLandmark(landmark, name, speed) {
            // The idea here is to "engage" an action at the start of the action, 
            // and then send the input only when it stops happening and disengage. 
            // For example, if you jump for 10 frames, it should engage at the start of the 
            // jump motion, and then only trigger one single input at the end of the jump
            // when speed or Y drop out of bounds. 

            // A jump or squat should override any ongoing left or right motion. The reason is
            // that when you jump or squat, your arms will probably move too. 
            console.log(name, speed)
            if (name === 'nose') {
                processLandmarkNose(landmark, speed);

            } else {
                processLandmarkWrist(landmark, name, speed);

            }
            updateDebugPanel(landmark, name, speed);
        }

        function updateDebugPanel(landmark, name, speed) {
            switch (name) {
                case 'leftWrist':
                    debugPanel.setActionData('leftWrist', { speed: speed });
                    break;
                case 'rightWrist':
                    debugPanel.setActionData('rightWrist', { speed: speed });
                    break;
                case 'nose':
                    if (landmark.y < getMinY('jump')) {
                        debugPanel.setActionData('jump', { speed: speed })
                    } else if (landmark.y > getMaxY('squat')) {
                        debugPanel.setActionData('squat', { speed: speed });
                    }
                    break;
            }
        }

        // New version that checks if Y is greater than average between min and max from calibration
        function processLandmarkNose(landmark, speed) {
            const y = landmark.y;
            let squatMinY = getMinY('squat');
            let jumpMinY = getMinY('jump');
            let squatMaxY = getMaxY('squat');  
            let jumpMaxY = getMaxY('jump');
            const jumpYThreshold = jumpMinY + (jumpMaxY - jumpMinY) * 0.5;
            const squatYThreshold = jumpMinY + (squatMaxY - squatMinY) * 0.5;
            const mult = configPanel.getValue('CONFIG', 'CONFIG.THRESHOLD_START_MULT');

            if (!visState.currentMotionData.engaged) {
                if (y < jumpYThreshold && speed > getThreshold('jump') * mult) {
                    visState.currentMotionData = {
                        engaged: true,
                        action: 'jump'
                    };
                    debugPanel.setLastAction('JumpInProgress');
                } else if (y > squatYThreshold && speed > getThreshold('squat') * mult) {
                    visState.currentMotionData = {
                        engaged: true,
                        action: 'squat'
                    };
                    debugPanel.setLastAction('SquatInProgress');
                }
            } else if (visState.currentMotionData.action === 'jump' || visState.currentMotionData.action === 'squat') {
                const action = visState.currentMotionData.action;
                const endMult = configPanel.getValue('CONFIG','THRESHOLD_END_MULT');
                if (speed < getThreshold(action) * endMult) {
                    visState.currentMotionData.engaged = false;
                    sendAction(action);
                    debugPanel.setLastAction(action);
                }
            }
        }

        function processLandmarkWrist(landmark, name, speed) {
            // Start leftWrist or rightWrist
            const threshold = getThreshold(name);
            const mult = configPanel.getValue('CONFIG','THRESHOLD_START_MULT');
            if (speed > threshold * mult) {
                visState.currentMotionData = {
                    engaged: true,
                    action: name
                };
                debugPanel.setActionData(name, { speed: speed });
                debugPanel.setLastAction(name + 'InProgress')
            } else if (visState.currentMotionData.engaged && visState.currentMotionData.action === name) {
                // End leftWrist or rightWrist
                // Bug -- obviusly this COULD be ending a DIFFERENT action, eg
                // right wrist starts action, left wrist stops it 

                action = visState.currentMotionData.action;
                const mult = configPanel.getValue('CONFIG','THRESHOLD_END_MULT');
                if (speed < threshold * mult) {
                    visState.currentMotionData.engaged = false;
                    sendAction(action)
                    debugPanel.setLastAction(name)
                }
            }
        }

        // Send the action into debouncing
        // 
        function sendAction(action) {
            console.log("Sending action ", action)
            switch (action) {
                case 'jump': debounceInput('h'); break;
                case 'squat': debounceInput('u'); break;
                case 'rightWrist': debounceInput('r'); break;
                case 'leftWrist': debounceInput('l'); break;
            }
        }

        // *** SPEED CALCULATION SYSTEM
        // This keeps a short term history for motion smoothing and anomaly detection
        // It is conceptually a completely separate module from the rest of video capture. It doesn't even
        // know what game state is.

        // This is kinda messy. Globals used in calculating speed. Should put these somewhere better. 

        let lastPositions = {
            leftWrist: [],
            rightWrist: [],
            nose: []
        };

        let speedStats = {
            mean: 0,
            stdDev: 0,
            count: 0,
            lastFrame: 0
        };

        function updateSpeedStats(speed) {
            speedStats.count++;
            const delta = speed - speedStats.mean;
            speedStats.mean += delta / speedStats.count;
            speedStats.stdDev += delta * (speed - speedStats.mean);

            if (speedStats.count > 1) {
                speedStats.stdDev = Math.sqrt(speedStats.stdDev / (speedStats.count - 1));
            }
        }

        function isAnomaly(speed) {
            if (speedStats.count < 30) return false; // Wait for enough data
            return Math.abs(speed - speedStats.mean) > configPanel.getValue('CONFIG','ANOMALY_MULTIPLIER') * speedStats.stdDev;
        }

        function calculateSpeed(landmark, name, frame) {
            if (frame - speedStats.lastFrame > 100) return 0;

            const currentTime = performance.now();
            const currentPosition = { x: landmark.x, y: landmark.y, time: currentTime };

            if (lastPositions[name].length === 0) {
                lastPositions[name].push(currentPosition);
                return 0;
            }

            const history = lastPositions[name];
            const oldestPosition = history[0];
            const dt = (currentTime - oldestPosition.time) / 1000; // in seconds

            if (dt < configPanel.getValue('CONFIG','MIN_TIME_THRESHOLD')) return 0;

            const dx = currentPosition.x - oldestPosition.x;
            const dy = currentPosition.y - oldestPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < configPanel.getValue('CONFIG','MIN_MOVEMENT_THRESHOLD') || distance > configPanel.getValue('CONFIG','MAX_MOVEMENT_THRESHOLD')) {
                return 0;
            }

            const speed = distance / dt;
            const scaledSpeed = speed * videoCanvas.width;

            updateSpeedStats(scaledSpeed);

            // Update history
            history.push(currentPosition);
            if (history.length > configPanel.getValue('CONFIG','HISTORY_SIZE')) {
                history.shift();
            }

            return scaledSpeed;
        }

        function updateEMAAlpha() {
            EMA_ALPHA = 1 / configPanel.getValue('CONFIG','SMOOTHING_LEVEL');
        }






        function drawVideoFrame(results) {
            videoCtx.save();
            videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoCtx.drawImage(results.image, 0, 0, videoCanvas.width, videoCanvas.height);

            if (results.poseLandmarks) {
                drawConnectors(videoCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                drawLandmarks(videoCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 2 });
            }

            videoCtx.restore();
        }

        function updateFPS() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTimestamp;
            lastTimestamp = currentTime;

            fps = 1000 / deltaTime;
            fpsHistory.push(fps);
            if (fpsHistory.length > FPS_AVERAGE_COUNT) {
                fpsHistory.shift();
            }

            const averageFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;

            // Update the DOM every 100 frames only
            if (visState.frameCount % 100 == 1) {
                fpsDisplay.textContent = `FPS: ${averageFps.toFixed(1)}`;
            }
        }

        function handleErrorState(status, message) {
            alertDisplay.textContent = message;
        }

        function clearErrorState() {
            alertDisplay.textContent = '';
        }

        function startGame() {
            visState.phase = 'game';
            document.getElementById('videoCanvas').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('startGame').style.display = 'none';
            isGameRunning = true;
            resetGameState();
            gameLoop();
        }
        // Event Listeners
        document.getElementById('startCalibration').addEventListener('click', startCalibration);
        document.getElementById('restartCalibration').addEventListener('click', startCalibration);
        document.getElementById('repeatStep').addEventListener('click', () => {
            if (visState.phase === 'practice') {
                visState.startTime = performance.now();
                updatePracticeDisplay();
            }
        });
        document.getElementById('startGame').addEventListener('click', () => {
            startGame();
        });



        // ----------------------------------------
        // ######      GAME COMPONENTS       ######
        // ----------------------------------------

        // The game is completely decoupled from the video processing. It just takes 
        // control inputs, as if you were using arrow keys on a keyboard. This is a 
        // pretty generic Tetris-like game implemented in WebGL. You can use it with
        // any other input device pretty easily. Keyboard controls also work just fine.

        // TODO: There is a flashing animation when a hard drop occurs, and a sliding 
        // animation whenever a row is eliminated. Neither work very well.

        // TODO: There is a hook for sound effects but none are implemented yet. 

        // Game configuration
        const COLUMNS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const DROP_INTERVAL = 4000; // Milliseconds between automatic drops

        // Game state
        let gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
        let currentPiece;
        let score = 0;
        let animatingRows = [];
        let animationStartTime = 0;
        let animationState = 'none';
        let slidingBlocks = [];
        let lastTime = 0;
        let dropCounter = 0;

        // Tetromino shapes and colors
        const SHAPES = [
            [[1, 1, 1, 1]],          // I
            [[1, 1], [1, 1]],        // O
            [[1, 1, 1], [0, 1, 0]],    // T
            [[1, 1, 1], [1, 0, 0]],    // L
            [[1, 1, 1], [0, 0, 1]],    // J
            [[1, 1, 0], [0, 1, 1]],    // S
            [[0, 1, 1], [1, 1, 0]]     // Z
        ];
        const COLORS = [
            [1, 0, 0, 1],    // Red
            [0, 1, 0, 1],    // Green
            [0, 0, 1, 1],    // Blue
            [1, 1, 0, 1],    // Yellow
            [1, 0, 1, 1],    // Magenta
            [0, 1, 1, 1],    // Cyan
            [1, .5, 0, 1]    // Orange
        ];

        // Initialize WebGL
        const canvas = document.getElementById('gameCanvas');

        // Input handling
        // TODO: Replace this with your custom input device logic
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowLeft': latestInput = 'l'; break;
                case 'ArrowRight': latestInput = 'r'; break;
                case 'ArrowDown': latestInput = 'd'; break;
                case 'ArrowUp': latestInput = 'u'; break;
                case ' ': latestInput = 'h'; break; // 'h' for hard drop
            }
        });

        // WebGL helper functions
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Shader source code
        const vertexShaderSource = `
            precision mediump float;
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            uniform vec2 u_resolution;
            varying vec2 v_texCoord;
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            uniform vec2 u_resolution;
            uniform float u_flash;
            varying vec2 v_texCoord;
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution;
                vec3 bgColor = mix(vec3(0.1, 0.1, 0.2), vec3(0.2, 0.2, 0.3), st.y);
                vec4 color = u_color;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(v_texCoord, center);
                color.rgb *= 0.8 + 0.2 * smoothstep(0.5, 0.0, dist);
                color.rgb += 0.1 * (1.0 - dist);
                float border = smoothstep(0.05, 0.07, min(min(v_texCoord.x, 1.0 - v_texCoord.x), min(v_texCoord.y, 1.0 - v_texCoord.y)));
                color.rgb *= 0.8 + 0.2 * border;
                vec3 flashColor = mix(mix(bgColor, color.rgb, color.a), vec3(1.0), u_flash);
                gl_FragColor = vec4(flashColor, 1.0);
            }
        `;

        // Create and set up WebGL program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        if (!program) {
            console.error('Failed to create shader program');
        } else {
            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const flashLocation = gl.getUniformLocation(program, "u_flash");
            const positionBuffer = gl.createBuffer();
            const texCoordBuffer = gl.createBuffer();

            // Resize canvas to fit the game field
            function resizeCanvas() {
                canvas.width = COLUMNS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Draw a rectangle (used for blocks and grid lines)
            function drawRectangle(x, y, width, height, color, flash = 0) {
                const yFlipped = canvas.height - y - height; // Flip y-coordinate for OpenGL
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, yFlipped, x + width, yFlipped, x, yFlipped + height, x, yFlipped + height, x + width, yFlipped, x + width, yFlipped + height]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(positionLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(texCoordLocation);

                gl.uniform4fv(colorLocation, color);
                gl.uniform1f(flashLocation, flash);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Draw the game field
            function drawField(flash = 0) {
                drawRectangle(0, 0, canvas.width, canvas.height, [0, 0, 0, 0], flash);
                for (let x = 0; x <= COLUMNS; x++) drawRectangle(x * BLOCK_SIZE - 1, 0, 2, canvas.height, [1, 1, 1, 0.2], flash);
                for (let y = 0; y <= ROWS; y++) drawRectangle(0, y * BLOCK_SIZE - 1, canvas.width, 2, [1, 1, 1, 0.2], flash);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLUMNS; x++) {
                        if (gameField[y][x] !== -1) {
                            let color = COLORS[gameField[y][x]];
                            let yPos = y;
                            if (animationState === 'sliding') {
                                const block = slidingBlocks.find(b => b.x === x && b.destY === y);
                                if (block) {
                                    const progress = (Date.now() - animationStartTime) / 500;
                                    yPos = block.startY + (y - block.startY) * progress;
                                }
                            }
                            drawRectangle(x * BLOCK_SIZE, yPos * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    }
                }
            }

            // Draw the current piece
            function drawPiece(flash = 0) {
                if (!currentPiece) return;
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            let color = COLORS[currentPiece.color];
                            drawRectangle((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    });
                });
            }

            // Create a new piece
            function createNewPiece() {
                const shapeIndex = Math.floor(Math.random() * SHAPES.length);
                return {
                    shape: SHAPES[shapeIndex],
                    x: Math.floor(COLUMNS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),
                    y: 0,
                    color: shapeIndex
                };
            }

            // Check for collisions
            function checkCollision() {
                return currentPiece.shape.some((row, y) => row.some((value, x) =>
                    value && (
                        y + currentPiece.y >= ROWS ||
                        x + currentPiece.x < 0 ||
                        x + currentPiece.x >= COLUMNS ||
                        (gameField[y + currentPiece.y] && gameField[y + currentPiece.y][x + currentPiece.x] !== -1)
                    )
                ));
            }

            // Rotate the current piece
            function rotatePiece() {
                const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
                const previousShape = currentPiece.shape;
                currentPiece.shape = rotated;
                if (checkCollision()) currentPiece.shape = previousShape;
            }

            // Move the current piece down
            function moveDown() {
                if (animationState !== 'none') return;
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    freezePiece();
                    checkLines();
                    if (animatingRows.length === 0) {
                        currentPiece = createNewPiece();
                        if (checkCollision()) {
                            // Game over
                            gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                            score = 0;
                            playSound('gameOver');
                        }
                    }
                }
            }

            // Freeze the current piece in place
            function freezePiece() {
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            gameField[y + currentPiece.y][x + currentPiece.x] = currentPiece.color;
                        }
                    });
                });
                playSound('pieceLand');
            }

            // Check for completed lines
            function checkLines() {
                animatingRows = [];
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (gameField[y].every(cell => cell !== -1)) animatingRows.push(y);
                }
                if (animatingRows.length > 0) {
                    animationState = 'sliding';
                    animationStartTime = Date.now();
                    slidingBlocks = [];
                    let rowsCleared = 0;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (animatingRows.includes(y)) {
                            rowsCleared++;
                        } else if (rowsCleared > 0) {
                            for (let x = 0; x < COLUMNS; x++) {
                                if (gameField[y][x] !== -1) {
                                    slidingBlocks.push({ x, startY: y, destY: y + rowsCleared });
                                }
                            }
                        }
                    }
                    playSound('lineCleared');
                }
            }

            // Update animation state
            function updateAnimation(deltaTime) {
                if (animationState === 'sliding' && Date.now() - animationStartTime > 500) {
                    animatingRows.sort((a, b) => b - a).forEach(y => {
                        gameField.splice(y, 1);
                        gameField.unshift(Array(COLUMNS).fill(-1));
                    });
                    slidingBlocks.forEach(block => {
                        gameField[block.destY][block.x] = gameField[block.startY][block.x];
                        gameField[block.startY][block.x] = -1;
                    });
                    score += animatingRows.length * 100;
                    animatingRows = [];
                    slidingBlocks = [];
                    animationState = 'none';
                    currentPiece = createNewPiece();
                }
            }

            // Perform a hard drop
            function hardDrop() {
                while (!checkCollision()) {
                    currentPiece.y++;
                }
                currentPiece.y--;
                freezePiece();
                checkLines();
                if (animatingRows.length === 0) {
                    currentPiece = createNewPiece();
                    if (checkCollision()) {
                        gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                        score = 0;
                    }
                }
                flashScreen();
                //playSoundEffect(audioFall)
            }

            // Flash the screen (for hard drop)
            let flashIntensity = 0;
            function flashScreen() {
                flashIntensity = 1;
            }

            // Handle input
            function handleInput() {
                if (animationState !== 'none') return;
                switch (latestInput) {
                    case 'l':
                        currentPiece.x--;
                        //playSoundEffect(audioLeft) // TODO don't play if collission
                        if (checkCollision()) {
                            currentPiece.x++;
                        }
                        break;
                    case 'r':
                        currentPiece.x++;
                        //playSoundEffect(audioRight) // TODO don't play if collission

                        if (checkCollision()) {
                            currentPiece.x--;
                        }
                        break;
                    case 'd':
                        moveDown();
                        break;
                    case 'u':
                        rotatePiece();
                        break;
                    case 'h':
                        hardDrop();
                        break;
                }
                latestInput = null; // Reset input after handling
            }

            // Play sound effects
            function playSound(action) {
                // TODO: Implement sound playback
                console.log(`Playing sound for: ${action}`);
            }

            function playSoundEffect(sound) {
                sound.currentTime = 0;
                sound.playSound();
            }

            // Update game state
            function update(deltaTime) {
                handleInput();
                dropCounter += deltaTime;
                if (dropCounter > DROP_INTERVAL) {
                    moveDown();
                    dropCounter = 0;
                }
                updateAnimation(deltaTime);
                if (flashIntensity > 0) {
                    flashIntensity = Math.max(0, flashIntensity - deltaTime / 100);
                }
            }

            function resetGameState() {
                gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                score = 0;
                currentPiece = createNewPiece();
                animatingRows = [];
                animationState = 'none';
                slidingBlocks = [];
                dropCounter = 0;
                actionHistory = [];
                //updateActionHistory(); not sure
            }

            // Main game loop
            function gameLoop(currentTime = 0) {
                if (!isGameRunning) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(deltaTime);

                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

                drawField(flashIntensity);
                drawPiece(flashIntensity);

                scoreElement.textContent = `Score: ${score}`;

                requestAnimationFrame(gameLoop);
            }

            // Start the game
            currentPiece = createNewPiece();
            gameLoop();
        }
    </script>
</body>

</html>