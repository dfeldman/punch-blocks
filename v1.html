<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris-like Game</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial, sans-serif; }
        #score { position: absolute; top: 20px; left: 20px; color: #e94560; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        #controls { position: absolute; top: 100px; left: 10px; display: flex; flex-direction: column; }
        #fps { position: absolute; top: 10px; right: 10px; color: #e94560; }
        #alert { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; color: red; }
        canvas { display: none; }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="startGame">Start Game</button>
        <label for="smoothing">Smoothing Level:</label>
        <input type="range" id="smoothing" name="smoothing" min="1" max="10" value="5">
        <label for="speedThreshold">Speed Threshold:</label>
        <input type="range" id="speedThreshold" name="speedThreshold" min="1" max="10" value="5">
        <label for="jumpThreshold">Jump Threshold (%):</label>
        <input type="range" id="jumpThreshold" name="jumpThreshold" min="1" max="100" value="70">
        <label for="squatThreshold">Squat Threshold (%):</label>
        <input type="range" id="squatThreshold" name="squatThreshold" min="1" max="100" value="30">
    </div>
    <div id="info">
        <div id="fps">FPS: 0</div>

        <div id="confidence">
            <div id="head">Head: </div>
            <div id="leftWrist">Left Wrist: </div>
            <div id="rightWrist">Right Wrist: </div>
        </div>
    </div>
    <div id="alert"></div>
    <canvas id="videoCanvas" width="640" height="480"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  
    <script>

        // This is really two separate real-time processing loops that are interleaved.
        // One is for video, and the other is for the game.
        // They only communicate through a few shared global variables. 

        // ----------------------------------------
        // ######      VIDEO COMPONENTS      ######
        // ----------------------------------------
        // The video processing code uses MediaPipe from Google to do pose recognition. 
        // Its input is a few config options. 
        // Its output is a status, positions, and an input to the game. 
        // Input may be "l", "r", "d", "h", "u". 
        // Status may be "OK" (everything is working), "BACKUP" (can't see necessary landmarks)
        // Positions are x/y positions for the left hand, head, and right hand for user feedback.
        // and more to be added later. 

        // Initialize MediaPipe Pose
        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');
        const gameCanvas = document.getElementById('gameCanvas');
        const gl = gameCanvas.getContext('webgl');
        const scoreElement = document.getElementById('score');
        const fpsDisplay = document.getElementById('fps');
        const alertDisplay = document.getElementById('alert');

        let isGameRunning = false;
        let lastTimestamp = performance.now();
        let fps = 0;
        let fpsHistory = [];
        const FPS_AVERAGE_COUNT = 10;

        let smoothingLevel = 5;
        let speedThreshold = 5;
        let jumpThreshold = 0.7;
        let squatThreshold = 0.3;

        let headPositions = [];
        let leftWristPositions = [];
        let rightWristPositions = [];

        const videoElement = document.createElement('video');
        videoElement.style.display = 'none';
        document.body.appendChild(videoElement);

        function onResults(results) {
            drawCircle([50,50], [0,0,0])

            const currentTimestamp = performance.now();
            fps = 1000 / (currentTimestamp - lastTimestamp);
            fpsHistory.push(fps);
            if (fpsHistory.length > FPS_AVERAGE_COUNT) {
                fpsHistory.shift();
            }
            const averageFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
            fpsDisplay.textContent = `FPS: ${averageFps.toFixed(2)}`;

            lastTimestamp = currentTimestamp;

            // Clear canvas
            //videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            //videoCtx.save();
            videoCtx.scale(-1, 1);
            videoCtx.translate(-videoCanvas.width, 0);
            //videoCtx.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);
            drawCircle({x:0.5, y:0.5}, "red")
            drawCircle({x:50, y:50}, "red")
            //videoCtx.restore();

            // Check if poseLandmarks exists and has the required landmarks
            if (!results.poseLandmarks || results.poseLandmarks.length < 17) {
                alertDisplay.textContent = "Pose landmarks not detected";
                return;
            }

            // Check if required landmarks are visible
            const landmarksToCheck = [
                results.poseLandmarks[0],  // Nose
                results.poseLandmarks[11], // Left shoulder
                results.poseLandmarks[12], // Right shoulder
                results.poseLandmarks[13], // Left elbow
                results.poseLandmarks[14], // Right elbow
                results.poseLandmarks[15], // Left wrist
                results.poseLandmarks[16]  // Right wrist
            ];

            if (!areLandmarksVisible(landmarksToCheck)) {
                alertDisplay.textContent = "BACK UP";
            } else {
                alertDisplay.textContent = "";
            }

            // Process landmarks
            console.log('Processing landmarks...');
            processLandmark(results.poseLandmarks[0], headPositions, 'blue', 'Head'); // Nose (head)
            processLandmark(results.poseLandmarks[15], leftWristPositions, 'red', 'Left Wrist'); // Left wrist
            processLandmark(results.poseLandmarks[16], rightWristPositions, 'green', 'Right Wrist'); // Right wrist
        }

        function areLandmarksVisible(landmarks) {
            return landmarks.every(landmark => landmark && landmark.visibility > 0.75);
        }

        function processLandmark(landmark, positionArray, color, name) {
            return;
            if (landmark && landmark.visibility > 0.75) {
                const currentTime = performance.now();
                positionArray.push({ x: landmark.x, y: landmark.y, time: currentTime });
                positionArray = positionArray.filter(pos => currentTime - pos.time <= smoothingLevel * 100);

                // Calculate the average position
                const avgPosition = positionArray.reduce((acc, pos) => ({
                    x: acc.x + pos.x,
                    y: acc.y + pos.y
                }), { x: 0, y: 0 });

                avgPosition.x /= positionArray.length;
                avgPosition.y /= positionArray.length;

                console.log(`Drawing ${name} at (${avgPosition.x}, ${avgPosition.y}) with color ${color}`);

                // Draw the smoothed position
                drawCircle(avgPosition, color);

                // Calculate speed and determine action
                if (positionArray.length >= 2) {
                    const latestPos = positionArray[positionArray.length - 1];
                    const previousPos = positionArray[positionArray.length - 2];

                    const dx = latestPos.x - previousPos.x;
                    const dy = latestPos.y - previousPos.y;
                    const dt = (latestPos.time - previousPos.time) / 1000; // in seconds

                    const speed = Math.sqrt(dx * dx + dy * dy) * videoCanvas.width / dt;

                    console.log(`${name} speed: ${speed.toFixed(2)} px/s`);

                    if (name === 'Left Wrist' && speed > speedThreshold) {
                        latestInput = 'l';
                        console.log('Punch Left');
                    } else if (name === 'Right Wrist' && speed > speedThreshold) {
                        latestInput = 'r';
                        console.log('Punch Right');
                    } else if (name === 'Head') {
                        if (avgPosition.y < squatThreshold) {
                            latestInput = 'd';
                            console.log('Squat');
                        } else if (avgPosition.y > jumpThreshold) {
                            latestInput = 'u';
                            console.log('Jump');
                        }
                    }

                    if (speed > 500) {
                        alertDisplay.textContent = "FAST MOVE";
                    } else {
                        alertDisplay.textContent = "";
                    }
                }
            }
            drawCircle({x:0.5, y:0.5}, "red")
        }

        // function drawCircle(position, color) {
        //     // Convert normalized coordinates (0-1) to canvas coordinates
        //     const x = position.x * videoCanvas.width;
        //     const y = position.y * videoCanvas.height;

        //     console.log(`drawCircle at (${x}, ${y}) with color ${color}`);
        //     //videoCtx.save(); // Save the current state
        //     videoCtx.beginPath();
        //     videoCtx.arc(x, y, 10, 0, 2 * Math.PI);
        //     videoCtx.fillStyle = color;
        //     videoCtx.fill();
        //     //videoCtx.restore(); // Restore the saved state
        // }

        function drawCircle(position, color) {
            const x = (videoCanvas.width - (position.x * videoCanvas.width))
            const y = position.y * videoCanvas.height;
            console.log("DRAW CIRCLE AT", x, y)
            videoCtx.save()
            videoCtx.beginPath();
            videoCtx.arc(x, y, 10, 0, 2 * Math.PI);
            videoCtx.fillStyle = color;
            videoCtx.fill();
            videoCtx.restore();
        }


        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/${file}`
        });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);

        let camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });
        camera.start();
        videoElement.style.display = 'block';


        document.getElementById('smoothing').addEventListener('input', (event) => {
            smoothingLevel = parseInt(event.target.value, 10);
        });

        document.getElementById('speedThreshold').addEventListener('input', (event) => {
            speedThreshold = parseInt(event.target.value, 10);
        });

        document.getElementById('jumpThreshold').addEventListener('input', (event) => {
            jumpThreshold = parseInt(event.target.value, 10) / 100;
        });

        document.getElementById('squatThreshold').addEventListener('input', (event) => {
            squatThreshold = parseInt(event.target.value, 10) / 100;
        });

        document.getElementById('startGame').addEventListener('click', () => {
            document.getElementById('videoCanvas').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('startGame').style.display = 'none';
            isGameRunning = true;
            gameLoop();
        });




        // ----------------------------------------
        // ######      GAME COMPONENTS       ######
        // ----------------------------------------

        // The game is completely decoupled from the video processing. It just takes 
        // control inputs, as if you were using arrow keys on a keyboard. This is a 
        // pretty generic Tetris-like game implemented in WebGL. You can use it with
        // any other input device pretty easily. Keyboard controls also work just fine.

        // TODO: There is a flashing animation when a hard drop occurs, and a sliding 
        // animation whenever a row is eliminated. Neither work very well.

        // TODO: There is a hook for sound effects but none are implemented yet. 

        // Game configuration
        const COLUMNS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const DROP_INTERVAL = 1000; // Milliseconds between automatic drops

        // Game state
        let gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
        let currentPiece;
        let score = 0;
        let animatingRows = [];
        let animationStartTime = 0;
        let animationState = 'none';
        let slidingBlocks = [];
        let lastTime = 0;
        let dropCounter = 0;

        // Tetromino shapes and colors
        const SHAPES = [
            [[1,1,1,1]],          // I
            [[1,1],[1,1]],        // O
            [[1,1,1],[0,1,0]],    // T
            [[1,1,1],[1,0,0]],    // L
            [[1,1,1],[0,0,1]],    // J
            [[1,1,0],[0,1,1]],    // S
            [[0,1,1],[1,1,0]]     // Z
        ];
        const COLORS = [
            [1,0,0,1],    // Red
            [0,1,0,1],    // Green
            [0,0,1,1],    // Blue
            [1,1,0,1],    // Yellow
            [1,0,1,1],    // Magenta
            [0,1,1,1],    // Cyan
            [1,.5,0,1]    // Orange
        ];

        // Initialize WebGL
        const canvas = document.getElementById('gameCanvas');

        // Input handling
        // TODO: Replace this with your custom input device logic
        let latestInput = null;
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowLeft': latestInput = 'l'; break;
                case 'ArrowRight': latestInput = 'r'; break;
                case 'ArrowDown': latestInput = 'd'; break;
                case 'ArrowUp': latestInput = 'u'; break;
                case ' ': latestInput = 'h'; break; // 'h' for hard drop
            }
        });

        // WebGL helper functions
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Shader source code
        const vertexShaderSource = `
            precision mediump float;
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            uniform vec2 u_resolution;
            varying vec2 v_texCoord;
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            uniform vec2 u_resolution;
            uniform float u_flash;
            varying vec2 v_texCoord;
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution;
                vec3 bgColor = mix(vec3(0.1, 0.1, 0.2), vec3(0.2, 0.2, 0.3), st.y);
                vec4 color = u_color;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(v_texCoord, center);
                color.rgb *= 0.8 + 0.2 * smoothstep(0.5, 0.0, dist);
                color.rgb += 0.1 * (1.0 - dist);
                float border = smoothstep(0.05, 0.07, min(min(v_texCoord.x, 1.0 - v_texCoord.x), min(v_texCoord.y, 1.0 - v_texCoord.y)));
                color.rgb *= 0.8 + 0.2 * border;
                vec3 flashColor = mix(mix(bgColor, color.rgb, color.a), vec3(1.0), u_flash);
                gl_FragColor = vec4(flashColor, 1.0);
            }
        `;

        // Create and set up WebGL program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        if (!program) {
            console.error('Failed to create shader program');
        } else {
            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const flashLocation = gl.getUniformLocation(program, "u_flash");
            const positionBuffer = gl.createBuffer();
            const texCoordBuffer = gl.createBuffer();

            // Resize canvas to fit the game field
            function resizeCanvas() {
                canvas.width = COLUMNS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Draw a rectangle (used for blocks and grid lines)
            function drawRectangle(x, y, width, height, color, flash = 0) {
                const yFlipped = canvas.height - y - height; // Flip y-coordinate for OpenGL
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x,yFlipped,x+width,yFlipped,x,yFlipped+height,x,yFlipped+height,x+width,yFlipped,x+width,yFlipped+height]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(positionLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(texCoordLocation);

                gl.uniform4fv(colorLocation, color);
                gl.uniform1f(flashLocation, flash);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Draw the game field
            function drawField(flash = 0) {
                drawRectangle(0, 0, canvas.width, canvas.height, [0,0,0,0], flash);
                for (let x = 0; x <= COLUMNS; x++) drawRectangle(x * BLOCK_SIZE - 1, 0, 2, canvas.height, [1,1,1,0.2], flash);
                for (let y = 0; y <= ROWS; y++) drawRectangle(0, y * BLOCK_SIZE - 1, canvas.width, 2, [1,1,1,0.2], flash);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLUMNS; x++) {
                        if (gameField[y][x] !== -1) {
                            let color = COLORS[gameField[y][x]];
                            let yPos = y;
                            if (animationState === 'sliding') {
                                const block = slidingBlocks.find(b => b.x === x && b.destY === y);
                                if (block) {
                                    const progress = (Date.now() - animationStartTime) / 500;
                                    yPos = block.startY + (y - block.startY) * progress;
                                }
                            }
                            drawRectangle(x * BLOCK_SIZE, yPos * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    }
                }
            }

            // Draw the current piece
            function drawPiece(flash = 0) {
                if (!currentPiece) return;
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            let color = COLORS[currentPiece.color];
                            drawRectangle((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    });
                });
            }

            // Create a new piece
            function createNewPiece() {
                const shapeIndex = Math.floor(Math.random() * SHAPES.length);
                return {
                    shape: SHAPES[shapeIndex],
                    x: Math.floor(COLUMNS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),
                    y: 0,
                    color: shapeIndex
                };
            }

            // Check for collisions
            function checkCollision() {
                return currentPiece.shape.some((row, y) => row.some((value, x) => 
                    value && (
                        y + currentPiece.y >= ROWS ||
                        x + currentPiece.x < 0 || 
                        x + currentPiece.x >= COLUMNS ||
                        (gameField[y + currentPiece.y] && gameField[y + currentPiece.y][x + currentPiece.x] !== -1)
                    )
                ));
            }

            // Rotate the current piece
            function rotatePiece() {
                const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
                const previousShape = currentPiece.shape;
                currentPiece.shape = rotated;
                if (checkCollision()) currentPiece.shape = previousShape;
            }

            // Move the current piece down
            function moveDown() {
                if (animationState !== 'none') return;
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    freezePiece();
                    checkLines();
                    if (animatingRows.length === 0) {
                        currentPiece = createNewPiece();
                        if (checkCollision()) {
                            // Game over
                            gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                            score = 0;
                            playSound('gameOver');
                        }
                    }
                }
            }

            // Freeze the current piece in place
            function freezePiece() {
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            gameField[y + currentPiece.y][x + currentPiece.x] = currentPiece.color;
                        }
                    });
                });
                playSound('pieceLand');
            }

            // Check for completed lines
            function checkLines() {
                animatingRows = [];
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (gameField[y].every(cell => cell !== -1)) animatingRows.push(y);
                }
                if (animatingRows.length > 0) {
                    animationState = 'sliding';
                    animationStartTime = Date.now();
                    slidingBlocks = [];
                    let rowsCleared = 0;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (animatingRows.includes(y)) {
                            rowsCleared++;
                        } else if (rowsCleared > 0) {
                            for (let x = 0; x < COLUMNS; x++) {
                                if (gameField[y][x] !== -1) {
                                    slidingBlocks.push({x, startY: y, destY: y + rowsCleared});
                                }
                            }
                        }
                    }
                    playSound('lineCleared');
                }
            }

            // Update animation state
            function updateAnimation(deltaTime) {
                if (animationState === 'sliding' && Date.now() - animationStartTime > 500) {
                    animatingRows.sort((a, b) => b - a).forEach(y => {
                        gameField.splice(y, 1);
                        gamegameField.unshift(Array(COLUMNS).fill(-1));
                    });
                    slidingBlocks.forEach(block => {
                        gameField[block.destY][block.x] = gameField[block.startY][block.x];
                        gameField[block.startY][block.x] = -1;
                    });
                    score += animatingRows.length * 100;
                    animatingRows = [];
                    slidingBlocks = [];
                    animationState = 'none';
                    currentPiece = createNewPiece();
                }
            }

            // Perform a hard drop
            function hardDrop() {
                while (!checkCollision()) {
                    currentPiece.y++;
                }
                currentPiece.y--;
                freezePiece();
                checkLines();
                if (animatingRows.length === 0) {
                    currentPiece = createNewPiece();
                    if (checkCollision()) {
                        gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                        score = 0;
                    }
                }
                flashScreen();
                playSound('hardDrop');
            }

            // Flash the screen (for hard drop)
            let flashIntensity = 0;
            function flashScreen() {
                flashIntensity = 1;
            }

            // Handle input
            function handleInput() {
                if (animationState !== 'none') return;
                switch (latestInput) {
                    case 'l': 
                        currentPiece.x--;
                        if (checkCollision()) currentPiece.x++;
                        break;
                    case 'r':
                        currentPiece.x++;
                        if (checkCollision()) currentPiece.x--;
                        break;
                    case 'd':
                        moveDown();
                        break;
                    case 'u':
                        rotatePiece();
                        break;
                    case 'h':
                        hardDrop();
                        break;
                }
                latestInput = null; // Reset input after handling
            }

            // Play sound effects
            function playSound(action) {
                // TODO: Implement sound playback
                console.log(`Playing sound for: ${action}`);
            }

            // Update game state
            function update(deltaTime) {
                handleInput();
                dropCounter += deltaTime;
                if (dropCounter > DROP_INTERVAL) {
                    moveDown();
                    dropCounter = 0;
                }
                updateAnimation(deltaTime);
                if (flashIntensity > 0) {
                    flashIntensity = Math.max(0, flashIntensity - deltaTime / 100);
                }
            }

            // Main game loop
            function gameLoop(currentTime = 0) {
                if (!isGameRunning) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(deltaTime);

                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                drawField(flashIntensity);
                drawPiece(flashIntensity);
                
                scoreElement.textContent = `Score: ${score}`;

                requestAnimationFrame(gameLoop);
            }

            // Start the game
            currentPiece = createNewPiece();
            gameLoop();
        }
    </script>
</body>
</html>