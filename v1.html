<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punch Blocks</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1a);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            color: #b9a6ff;
        }

        #score,
        #fps,
        #speedDisplay {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #score {
            top: 20px;
            left: 20px;
        }

        #fps {
            top: 20px;
            right: 20px;
        }

        #speedDisplay {
            bottom: 20px;
            left: 20px;
        }

        #controls {
            position: absolute;
            top: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
        }

        #alert,
        #tutorial {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            text-align: center;
        }

        #alert {
            top: 100px;
            color: #f99797;
        }

        #tutorial {
            top: 50px;
            color: white;
        }

        button {
            font-size: 14px;
            padding: 10px 20px;
            margin: 5px;
            background: #b9a6ff;
            color: #1a1a2e;
            border: none;
            cursor: pointer;
        }

        #startGame {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
        }

        canvas {
            display: none;
            margin: auto;
        }

        #videoCanvas {
            position: absolute;
            display: block;
            max-width: 640px;
            max-height: 480px;
            width: 100%;
            height: auto;
        }

        #gameCanvas {
            position: absolute;
            top: 150px;
            height: 80vh;
            width: 40vh;
            border: 5px solid #b9a6ff;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin: 10px;
        }

        #actionHistory {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 16px;
        }


        /* Debug panel */

        #debugPanel {
            position: absolute;
            background-color: #2d2d2d;
            border-radius: 4px;
            padding: 10px;
            top: 600px;
            /* well below main content */
            left: 10px;
        }

        .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .group {
            background-color: #383838;
            border-radius: 4px;
            padding: 5px;
            width: 48%;
        }

        .meter-container {
            position: relative;
            margin-top: 2px;
        }

        .meter {
            background-color: #555;
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            transition: width 0.3s ease, background-color 0.3s ease;
            width: 0;
        }

        .meter-target,
        .meter-peak {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
        }

        .meter-target {
            background-color: #ff0;
        }

        .meter-peak {
            background-color: #f0f;
        }

        .warning {
            color: #f44;
            font-weight: bold;
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            display: none;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            margin-right: 5px;
        }

        .status-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .value {
            font-weight: bold;
            cursor: pointer;
        }

        .value:hover {
            text-decoration: underline;
        }

        .plot-container {
            display: none;
            background-color: #444;
            padding: 5px;
            margin-top: 5px;
            border-radius: 3px;
        }

        .plot {
            width: 100%;
            height: 100px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <label for="smoothing">Smoothing Level:</label>
        <input type="range" id="smoothing" name="smoothing" min="1" max="10" value="5">
        <label for="minSpeedThreshold">Minimum Speed Threshold:</label>
        <input type="range" id="minSpeedThreshold" name="minSpeedThreshold" min="100" max="500" value="250">
        <label for="calibrationAttempts">Calibration Attempts:</label>
        <input type="range" id="calibrationAttempts" name="calibrationAttempts" min="1" max="5" value="3">
        <label for="calibrationCountdown">Calibration Countdown (s):</label>
        <input type="range" id="calibrationCountdown" name="calibrationCountdown" min="1" max="10" value="3">
        <label for="calibrationThresholdMultiplier">Calibration Threshold
            Multiplier (%):</label>
        <input type="range" id="calibrationThresholdMultiplier" name="calibrationThresholdMultiplier" min="50" max="100"
            value="90">
        <label for="jumpThreshold">Jump Height Threshold (%):</label>
        <input type="range" id="jumpThreshold" name="jumpThreshold" min="1" max="100" value="30">
        <label for="squatThreshold">Squat Height Threshold (%):</label>
        <input type="range" id="squatThreshold" name="squatThreshold" min="1" max="100" value="70">
        <button id="startCalibration">Start Calibration</button>
        <button id="restartCalibration">Restart Calibration</button>
        <button id="repeatStep">Repeat Step</button>
    </div>
    <div id="fps">FPS: 0</div>
    <div id="alert"></div>
    <div id="tutorial"></div>
    <div id="speedDisplay"></div>
    <div id="actionHistory"></div>
    <canvas id="videoCanvas" width="640" height="480"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <button id="startGame" style="display:none;">Start Game</button>

    <div id="debugPanel">
        <div class="status-line">
            <h2>Debug Panel</h2>
            <span>Status: <span id="captureStatus" class="value"></span></span>
            <span>Last Action: <span id="lastAction" class="value"></span></span>
            <button id="toggleButton">Hide</button>
            <button id="pauseButton">Pause</button>
        </div>
        <div id="captureWarning" class="warning"></div>
        <div id="debugContent"></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script>
        // DEBUG PANEL
        // This is primarily to help in figuring out the calibration system.
        // It may be removed and disabled in the future. 

        class DebugPanel {
            constructor() {
                this.data = {
                    captureStatus: '',
                    captureWarning: '',
                    lastAction: '',
                    actions: {
                        rightWrist: { speed: 0, target: 50, peak: 0 },
                        leftWrist: { speed: 0, target: 50, peak: 0 },
                        jump: { speed: 0, speedTarget: 50, y: 0, yTarget: 50, yPeak: 0 },
                        squat: { speed: 0, speedTarget: 50, y: 0, yTarget: 50, yPeak: 0 }
                    }
                };
                this.lastUpdate = Date.now();
                this.lastPeakClear = Date.now();
                this.peakClearInterval = 3000; // Clear peaks every 3 seconds
                this.isVisible = true;
                this.isPaused = false;
                this.plotData = {};
                this.maxPlotPoints = 100;

                this.initElements();
                this.createActionGroups();
                this.initEventListeners();
            }

            initElements() {
                this.elements = {
                    captureStatus: document.getElementById('captureStatus'),
                    captureWarning: document.getElementById('captureWarning'),
                    lastAction: document.getElementById('lastAction'),
                    toggleButton: document.getElementById('toggleButton'),
                    pauseButton: document.getElementById('pauseButton'),
                    debugContent: document.getElementById('debugContent')
                };
            }

            createActionGroups() {
                const content = document.createDocumentFragment();
                let row;
                Object.keys(this.data.actions).forEach((action, index) => {
                    if (index % 2 === 0) {
                        row = document.createElement('div');
                        row.className = 'row';
                        content.appendChild(row);
                    }
                    const group = this.createActionGroup(action);
                    row.appendChild(group);
                });
                this.elements.debugContent.appendChild(content);
            }

            createActionGroup(action) {
                const group = document.createElement('div');
                group.className = 'group';
                group.innerHTML = `
                    <h3>${action.charAt(0).toUpperCase() + action.slice(1)}</h3>
                    <div>Speed: <span id="${action}Speed" class="value" onclick="debugPanel.togglePlot('${action}', 'speed')"></span> / <span id="${action}Target"></span></div>
                    <div>Peak: <span id="${action}Peak" class="value" onclick="debugPanel.togglePlot('${action}', 'peak')"></span></div>
                    <div class="meter-container">
                        <div class="meter">
                            <div id="${action}Meter" class="meter-fill"></div>
                        </div>
                        <div id="${action}TargetMark" class="meter-target"></div>
                        <div id="${action}PeakMark" class="meter-peak"></div>
                    </div>
                    <div id="${action}SpeedPlot" class="plot-container">
                        <canvas class="plot"></canvas>
                    </div>
                    <div id="${action}PeakPlot" class="plot-container">
                        <canvas class="plot"></canvas>
                    </div>
                    ${!action.includes('Wrist') ? `
                        <div>Y: <span id="${action}Y" class="value" onclick="debugPanel.togglePlot('${action}', 'y')"></span> / <span id="${action}YTarget"></span></div>
                        <div>Y Peak: <span id="${action}YPeak" class="value" onclick="debugPanel.togglePlot('${action}', 'yPeak')"></span></div>
                        <div class="meter-container">
                            <div class="meter">
                                <div id="${action}YMeter" class="meter-fill"></div>
                            </div>
                            <div id="${action}YTargetMark" class="meter-target"></div>
                            <div id="${action}YPeakMark" class="meter-peak"></div>
                        </div>
                        <div id="${action}YPlot" class="plot-container">
                            <canvas class="plot"></canvas>
                        </div>
                        <div id="${action}YPeakPlot" class="plot-container">
                            <canvas class="plot"></canvas>
                        </div>
                    ` : ''}
                `;
                return group;
            }

            initEventListeners() {
                this.elements.toggleButton.addEventListener('click', () => this.toggleVisibility());
                this.elements.pauseButton.addEventListener('click', () => this.togglePause());
            }

            setCaptureStatus(status) {
                if (this.isPaused) return;
                this.data.captureStatus = status;
            }

            setCaptureWarning(warning) {
                if (this.isPaused) return;
                this.data.captureWarning = warning;
                this.elements.captureWarning.style.display = warning ? 'block' : 'none';
            }

            setLastAction(action) {
                if (this.isPaused) return;
                this.data.lastAction = action;
            }

            setActionData(action, data) {
                if (this.isPaused) return;
                const currentData = this.data.actions[action];
                this.data.actions[action] = { ...currentData, ...data };

                if ((data.speed ?? 0) > (currentData.peak ?? 0)) {
                    this.data.actions[action].peak = data.speed;
                }

                if ((data.y ?? 0) > (currentData.yPeak ?? 0)) {
                    this.data.actions[action].yPeak = data.y;
                }

                // Update plot data
                Object.keys(data).forEach(key => {
                    const plotKey = `${action}_${key}`;
                    if (!this.plotData[plotKey]) {
                        this.plotData[plotKey] = [];
                    }
                    this.plotData[plotKey].push(data[key]);
                    if (this.plotData[plotKey].length > this.maxPlotPoints) {
                        this.plotData[plotKey].shift();
                    }
                });
            }

            clearPeaks() {
                Object.keys(this.data.actions).forEach(action => {
                    this.data.actions[action].peak = 0;
                    if (this.data.actions[action].yPeak !== undefined) {
                        this.data.actions[action].yPeak = 0;
                    }
                });
            }

            toggleVisibility() {
                this.isVisible = !this.isVisible;
                this.elements.debugContent.style.display = this.isVisible ? 'block' : 'none';
                this.elements.toggleButton.textContent = this.isVisible ? 'Hide' : 'Show';
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                this.elements.pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
            }

            togglePlot(action, type) {
                const plotContainer = document.getElementById(`${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot`);
                if (plotContainer.style.display === 'none' || plotContainer.style.display === '') {
                    plotContainer.style.display = 'block';
                    this.updatePlot(action, type);
                } else {
                    plotContainer.style.display = 'none';
                }
            }

            updatePlot(action, type) {
                const plotKey = `${action}_${type}`;
                const canvas = document.querySelector(`#${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot canvas`);
                const ctx = canvas.getContext('2d');
                const data = this.plotData[plotKey];

                if (!data || data.length === 0) return;

                const width = canvas.width;
                const height = canvas.height;
                const max = Math.max(...data);
                const min = Math.min(...data);

                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;

                data.forEach((value, index) => {
                    const x = (index / (data.length - 1)) * width;
                    const y = height - ((value - min) / (max - min)) * height;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();
            }

            updateDOM() {
                if (!this.isVisible) return;
                const now = Date.now();
                if (now - this.lastUpdate < 100) return;
                this.lastUpdate = now;

                if (now - this.lastPeakClear >= this.peakClearInterval) {
                    this.clearPeaks();
                    this.lastPeakClear = now;
                }

                this.elements.captureStatus.textContent = this.data.captureStatus;
                this.elements.captureWarning.textContent = this.data.captureWarning;
                this.elements.lastAction.textContent = this.data.lastAction;

                Object.entries(this.data.actions).forEach(([action, data]) => {
                    this.updateActionInfo(action, data);
                });
            }

            updateActionInfo(action, data) {
                const speed = document.getElementById(`${action}Speed`);
                const target = document.getElementById(`${action}Target`);
                const peak = document.getElementById(`${action}Peak`);
                const meter = document.getElementById(`${action}Meter`);
                const targetMark = document.getElementById(`${action}TargetMark`);
                const peakMark = document.getElementById(`${action}PeakMark`);

                if (speed) speed.textContent = (data.speed ?? 0).toFixed(2);
                if (target) target.textContent = ((data.target ?? data.speedTarget) ?? 0).toFixed(2);
                if (peak) peak.textContent = (data.peak ?? 0).toFixed(2);

                this.updateMeter(
                    meter,
                    targetMark,
                    peakMark,
                    data.speed ?? 0,
                    (data.target ?? data.speedTarget) ?? 0,
                    data.peak ?? 0
                );

                if (!action.includes('Wrist')) {
                    const yValue = document.getElementById(`${action}Y`);
                    const yTarget = document.getElementById(`${action}YTarget`);
                    const yPeak = document.getElementById(`${action}YPeak`);
                    const yMeter = document.getElementById(`${action}YMeter`);
                    const yTargetMark = document.getElementById(`${action}YTargetMark`);
                    const yPeakMark = document.getElementById(`${action}YPeakMark`);

                    if (yValue) yValue.textContent = (data.y ?? 0).toFixed(2);
                    if (yTarget) yTarget.textContent = (data.yTarget ?? 0).toFixed(2);
                    if (yPeak) yPeak.textContent = (data.yPeak ?? 0).toFixed(2);

                    this.updateMeter(
                        yMeter,
                        yTargetMark,
                        yPeakMark,
                        data.y ?? 0,
                        data.yTarget ?? 0,
                        data.yPeak ?? 0
                    );
                }

                // Update plots if they are visible
                ['speed', 'peak', 'y', 'yPeak'].forEach(type => {
                    const plotContainer = document.getElementById(`${action}${type.charAt(0).toUpperCase() + type.slice(1)}Plot`);
                    if (plotContainer && plotContainer.style.display !== 'none') {
                        this.updatePlot(action, type);
                    }
                });
            }

            updateMeter(meter, targetMark, peakMark, value, target, peak) {
                if (!meter || !targetMark || !peakMark) return;

                const percentage = Math.min(Math.max(((value ?? 0) / 100) * 100, 0), 100);
                const targetPercentage = Math.min(Math.max(((target ?? 0) / 100) * 100, 0), 100);
                const peakPercentage = Math.min(Math.max(((peak ?? 0) / 100) * 100, 0), 100);

                meter.style.width = `${percentage}%`;
                targetMark.style.left = `${targetPercentage}%`;
                peakMark.style.left = `${peakPercentage}%`;

                const diff = Math.abs((value ?? 0) - (target ?? 0));
                meter.style.backgroundColor = diff <= 10 ? '#4CAF50' : diff <= 20 ? '#FFA500' : '#FF4444';
            }
        }


    </script>
    <script>

        // TODO Cross Origin Isolation will improve the timing accuracy fom 100us to 5us
        // timing accuracy is greatly needed for speed measurment

        // I think I can do that with s3 bucket headers???

        // Conceptual design
        // 1. Input from mediaPipe (onResults)
        // 2. Speed calculation for landmarks using history, EMA, and anomaly detection
        // 3. (Landmark speeds go into debugPanel, which is not normally displayed)
        // 4. In calibration mode only, these speeds are used to set thresholds that go into landmarkInfo
        // 5. In practice mode, the speeds are compared to the thresholds, but not used for anything
        // 6. In game mode:
        //   a. Debouncing -- multiple copies of the same input are ignored
        //   b. Fed into game logic as a keyboard input (left, right, h for hard drop) 
        // Each component shares minimal data. For example the calibration data history is totally separate 
        // from the speed calculation history.

        // The main steps are:
        // 1. Nothing, welcome screen
        // 2. Enable camera
        // 3. Calibration
        // 4. Practice
        // 5. Play game

        // The calibration phases are:
        // For each action:
        //    For each attempt:
        //        (If not first attempt) wait 3 seconds. Display a countdown. 
        //        Measure peak speed and min, max Y of the action
        //    Average the 3 attempts and save it in the landmarkInfo data



        // Constants and Configuration
        let CONFIG = {
            MIN_SPEED_THRESHOLD: 1000,
            MIN_SPEED_THRESHOLD_HEAD: 600,
            ATTEMPT_DURATION: 2000,
            CALIBRATION_ATTEMPTS: 1, // 3,
            CALIBRATION_COUNTDOWN: 3,
            CALIBRATION_THRESHOLD_MULTIPLIER: 0.9,
            JUMP_THRESHOLD: 0.3,
            SQUAT_THRESHOLD: 0.7,
            TIME_WINDOW: 100,
            DEBOUNCE_FRAMES: 4,
            PEAK_SPEED_WINDOW: 1000,
            // These are new and don't all have controls yet
            SMOOTHING_LEVEL: 5,
            HISTORY_SIZE: 5,
            MIN_MOVEMENT_THRESHOLD: 0.001, // 0.1% of canvas width
            MAX_MOVEMENT_THRESHOLD: 0.5,   // 50% of canvas width
            MIN_TIME_THRESHOLD: 1 / 120,   // Assuming max 120 FPS
            ANOMALY_MULTIPLIER: 3,         // For dynamic anomaly detection
            WAIT_TIME: 1000,               // 3 seconds
        };

        // Update CONFIG based on slider inputs
        document.getElementById('smoothing').addEventListener('input', (e) => {
            CONFIG.SMOOTHING_LEVEL = parseInt(e.target.value);
            updateEMAAlpha();
        });
        document.getElementById('minSpeedThreshold').addEventListener('input', (e) => CONFIG.MIN_SPEED_THRESHOLD = parseInt(e.target.value));
        document.getElementById('calibrationAttempts').addEventListener('input', (e) => CONFIG.CALIBRATION_ATTEMPTS = parseInt(e.target.value));
        document.getElementById('calibrationCountdown').addEventListener('input', (e) => CONFIG.CALIBRATION_COUNTDOWN = parseInt(e.target.value));
        document.getElementById('calibrationThresholdMultiplier').addEventListener('input', (e) => CONFIG.CALIBRATION_THRESHOLD_MULTIPLIER = parseInt(e.target.value) / 100);
        document.getElementById('jumpThreshold').addEventListener('input', (e) => CONFIG.JUMP_THRESHOLD = parseInt(e.target.value) / 100);
        document.getElementById('squatThreshold').addEventListener('input', (e) => CONFIG.SQUAT_THRESHOLD = parseInt(e.target.value) / 100);

        // Global Variables
        // This is not really a constant oops
        let EMA_ALPHA = 1 / CONFIG.SMOOTHING_LEVEL;

        const videoElement = document.createElement('video');
        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');
        const gameCanvas = document.getElementById('gameCanvas');
        const gl = gameCanvas.getContext('webgl');
        const scoreElement = document.getElementById('score');
        const fpsDisplay = document.getElementById('fps');
        const alertDisplay = document.getElementById('alert');
        const tutorialDisplay = document.getElementById('tutorial');
        const speedDisplay = document.getElementById('speedDisplay');
        const actionHistoryDisplay = document.getElementById('actionHistory');

        let isGameRunning = false;
        let lastTimestamp = performance.now();
        let fps = 0;
        let fpsHistory = [];
        const FPS_AVERAGE_COUNT = 10;

        let latestInput = null;
        let actionHistory = [];
        const MAX_HISTORY = 5;


        const debugPanel = new DebugPanel();
        debugPanel.setCaptureStatus('Active');

        // Landmark Configuration
        // This is constant configuration. It's just which landmarks we should care
        // continue processing. If a landmark isn't in here it is completely ignored.
        const landmarkConfig = {
            leftWrist: { index: 15, color: 'red' },
            rightWrist: { index: 16, color: 'green' },
            nose: { index: 0, color: 'blue' },
            // not sure these are correct
            //jump: { index: 0, color: 'green' },
            //squat: { index: 0, color: 'purple' }
        };

        // This is used for the calibration/practice state machine. 
        // It isn't really used for the game itself. 
        // The gameState opject is totally rewritten in each step. This is just an example I guess.
        let gameState = {
            phase: 'start', // 'idle', 'calibration', 'practice', 'game', 'pause', 'end'
            step: 'leftWrist', // leftWrist, rightWrist, jump, squat
            attempts: [], // maximum config.CALIBRATION_ATTEMPTS attempts 
            lastAttemptTime: 0, // After attempt 1, wait 1 second before next attempt
            //countdown: CONFIG.CALIBRATION_COUNTDOWN, NOT USED there is no time limit
            lastCountdownTime: 0,
            startTime: 0,
            maxTime: 30000, // 30 seconds max per step
            frameCount: 0,
            waitForCalibration: false,
            alertText: '',
            alertTime: 0
        };

        let calibrationData = {
            leftWrist: { speeds: [], threshold: 0 },
            rightWrist: { speeds: [], threshold: 0 },
            jump: { speeds: [], threshold: 0, maxY: 0, minY: 1 },
            squat: { speeds: [], threshold: 0, maxY: 0, minY: 1 }
        };

        // Debounce System
        let debounceCounters = { l: 0, r: 0, u: 0, h: 0, n: 0 };

        function resetDebounceCounters() {
            Object.keys(debounceCounters).forEach(key => debounceCounters[key] = 0);
        }

        function debounceInput(input) {
            let mult = (input === 'h' || input === 'u') ? 2 : 1;
            if (input) {
                debounceCounters[input]++;
                if (debounceCounters[input] >= (CONFIG.DEBOUNCE_FRAMES * mult)) {
                    sendInput(input);
                    resetDebounceCounters();
                }
            } else {
                resetDebounceCounters();
            }
        }

        function sendInput(input) {
            latestInput = input;
            const actionName = {
                'l': 'leftWrist',
                'r': 'rightWrist',
                'h': 'jump',
                'u': 'squat'
            }[input];
            updateSpeedDisplay(actionName, calibrationData[actionName].threshold);
        }

        // Calibration Functions
        function startCalibration() {
            isGameRunning = false;
            document.getElementById('videoCanvas').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'none';

            gameState = {
                phase: 'calibration',
                step: 'leftWrist',
                attempts: [],
                lastAttemptTime: 0,
                waitForCalibration: false,
                countdown: CONFIG.CALIBRATION_COUNTDOWN,
                lastCountdownTime: performance.now(),
                startTime: performance.now(),
                maxTime: 30000,
                frameCount: 0,
                alertText: '',
                alertTime: 0,
                currentAttemptData: {
                    maxSpeed: 0,
                    startTime: 0,
                    maxY: 0,
                    minY: 1
                },
            };
            updateCalibrationDisplay();
        }













        // function updateCalibration(landmark, speed) {
        //     // There's a huge bug here. It just captures the first moment that's above the threshold.
        //     // That means in general. the result will just be slightly above the threshold.


        //     if (gameState.waitForCalibration) return;

        //     threshold = CONFIG.MIN_SPEED_THRESHOLD;
        //     if (gameState.step == 'jump' || gameState.step == 'squat') {
        //         threshold = CONFIG.MIN_SPEED_THRESHOLD_HEAD;
        //     }

        //     if (speed >= threshold) {
        //         console.log("CALIBRATION STEP COMPLETE", gameState.step, speed)
        //         // Start waiting for next attempt right away
        //         gameState.attempts.push(speed);
        //         gameState.lastAttemptTime = performance.now();
        //         gameState.waitForCalibration = true;
        //         if (gameState.step === 'jump' || gameState.step === 'squat') {
        //             calibrationData[gameState.step].maxY = Math.max(calibrationData[gameState.step].maxY, landmark.y);
        //             calibrationData[gameState.step].minY = Math.min(calibrationData[gameState.step].minY, landmark.y);
        //         }
        //     }


        //     debugPanel.setActionData(gameState.step,
        //         {
        //             speed: speed,
        //             threshold: 100
        //             // Set threshold later
        //         })
        //     debugPanel.updateDOM();
        // }


        function updateCalibration(landmark, speed) {
            if (gameState.waitForCalibration) return;

            const threshold = (gameState.step === 'jump' || gameState.step === 'squat')
                ? CONFIG.MIN_SPEED_THRESHOLD_HEAD
                : CONFIG.MIN_SPEED_THRESHOLD;

            const currentTime = performance.now();

            // Start a new attempt if we haven't started one yet
            if (gameState.currentAttemptData.startTime === 0 && speed >= threshold) {
                gameState.currentAttemptData = {
                    maxSpeed: speed,
                    startTime: currentTime,
                    maxY: landmark.y,
                    minY: landmark.y
                };
                console.log("Started new calibration attempt for", gameState.step);
            }

            // Update attempt data if we're in the middle of an attempt
            if (gameState.currentAttemptData.startTime !== 0) {
                gameState.currentAttemptData.maxSpeed = Math.max(gameState.currentAttemptData.maxSpeed, speed);

                if (gameState.step === 'jump' || gameState.step === 'squat') {
                    gameState.currentAttemptData.maxY = Math.max(gameState.currentAttemptData.maxY, landmark.y);
                    gameState.currentAttemptData.minY = Math.min(gameState.currentAttemptData.minY, landmark.y);
                }
                
                if (currentTime - gameState.currentAttemptData.startTime >= CONFIG.ATTEMPT_DURATION) {
                    finishCalibrationAttempt();
                }
            }


            debugPanel.setActionData(gameState.step, {
                speed: speed,
                threshold: threshold
            });
            debugPanel.updateDOM();
        }















        // function finishCalibrationStep() {
        //     const avgSpeed = gameState.attempts.reduce((a, b) => a + b, 0) / gameState.attempts.length;
        //     //calibrationData[gameState.step].speeds = gameState.attempts; not used
        //     calibrationData[gameState.step].threshold = avgSpeed * CONFIG.CALIBRATION_THRESHOLD_MULTIPLIER;


        //     gameState.attempts = [];
        //     gameState.countdown = CONFIG.CALIBRATION_COUNTDOWN;
        //     gameState.lastCountdownTime = performance.now();
        //     gameState.startTime = performance.now();
        //     updateCalibrationDisplay();
        // }


        function finishCalibrationAttempt() {
            console.log("Finished calibration attempt for", gameState.step, "Max speed:", gameState.currentAttemptData.maxSpeed);

            gameState.attempts.push(gameState.currentAttemptData.maxSpeed);

            if (gameState.step === 'jump' || gameState.step === 'squat') {
                calibrationData[gameState.step].maxY = gameState.currentAttemptData.maxY;
                calibrationData[gameState.step].minY = gameState.currentAttemptData.minY;
            }

            gameState.lastAttemptTime = performance.now();
            gameState.waitForCalibration = true;
            gameState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };

        }


        function finishCalibrationStep() {
            const avgSpeed = gameState.attempts.reduce((a, b) => a + b, 0) / gameState.attempts.length;
            calibrationData[gameState.step].threshold = avgSpeed * CONFIG.CALIBRATION_THRESHOLD_MULTIPLIER;
            gameState.attempts = [];
            gameState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };
        }









        function finishCalibration() {
            gameState.phase = 'practice';
            startPracticeStage();
        }

        function restartCalibrationStep() {
            gameState.attempts = [];
            gameState.countdown = CONFIG.CALIBRATION_COUNTDOWN;
            gameState.startTime = performance.now();
            updateCalibrationDisplay();
        }

        function updateCalibrationDisplay() {
            if (gameState.phase === 'game') {
                tutorialDisplay.textContent = "Running";
                return;
            }

            const stepName = gameState.step.charAt(0).toUpperCase() + gameState.step.slice(1);

            if (gameState.waitForCalibration) {
                tutorialDisplay.textContent = `Calibrating ${stepName}: Wait for next attempt`;
            } else {
                tutorialDisplay.textContent = `Calibrating ${stepName}: Perform action ${gameState.attempts.length + 1}/${CONFIG.CALIBRATION_ATTEMPTS}`;
            }
        }

        // Practice Stage Functions
        // Everything here needs to be rewritten
        function startPracticeStage() {
            isGameRunning = false;
            document.getElementById('videoCanvas').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'none';

            gameState = {
                phase: 'practice',
                step: 'leftWrist',
                completed: [],
                startTime: performance.now(),
                maxTime: 60000, // 60 seconds for entire practice
                frameCount: 0
            };
            updatePracticeDisplay();
        }

        function updatePractice(step, landmark, speed) {
            if (performance.now() - gameState.startTime > gameState.maxTime) {
                finishPractice();
                return;
            }

            const threshold = calibrationData[step].threshold;
            const percentOfThreshold = (speed / threshold) * 100;

            if (speed >= threshold) {
                showSuccess(`Great job! ${speed.toFixed(0)} speed (${percentOfThreshold.toFixed(0)}% of threshold)`);
                gameState.completed.push(step);
                moveToNextPracticeStep();
            } else if (speed >= CONFIG.MIN_SPEED_THRESHOLD) {
                showWarning(`Close! ${speed.toFixed(0)} speed (${percentOfThreshold.toFixed(0)}% of threshold). Try again!`);
            }
            updatePracticeDisplay();
        }

        function moveToNextPracticeStep() {
            switch (gameState.step) {
                case 'leftWrist': gameState.step = 'rightWrist'; break;
                case 'rightWrist': gameState.step = 'jump'; break;
                case 'jump': gameState.step = 'squat'; break;
                case 'squat': finishPractice(); return;
            }
            updatePracticeDisplay();
        }

        function finishPractice() {
            gameState.phase = 'ready';
            document.getElementById('startGame').style.display = 'block';
            tutorialDisplay.textContent = "Great job! You're ready to play!";
            alertDisplay.textContent = "Click 'Start Game' when you're ready.";
        }

        function updatePracticeDisplay() {
            const stepName = gameState.step.charAt(0).toUpperCase() + gameState.step.slice(1);
            tutorialDisplay.textContent = `Practice ${stepName}`;
            alertDisplay.textContent = `Completed: ${gameState.completed.join(', ')}`;
        }

        // TODO use the gamestate.alert to display messages
        function showWarning(message) {
            alertDisplay.textContent = message;
            alertDisplay.style.color = '#ffaa00';
            setTimeout(() => {
                alertDisplay.style.color = '#f99797';
            }, 2000);
        }

        function showSuccess(message) {
            alertDisplay.textContent = message;
            alertDisplay.style.color = '#00ff00';
            setTimeout(() => {
                alertDisplay.style.color = '#f99797';
            }, 2000);
        }

        // Speed Display and Action History
        function updateSpeedDisplay(action, speed) {
            const actionColor = {
                leftWrist: 'red',
                rightWrist: 'blue',
                jump: 'green',
                squat: 'purple'
            }[action] || 'black';

            speedDisplay.innerHTML = `<span style="color:${actionColor}">${action.toUpperCase()}</span> ${speed.toFixed(0)}`;

            actionHistory.unshift({ action, speed, time: new Date() });
            if (actionHistory.length > MAX_HISTORY) {
                actionHistory.pop();
            }

            updateActionHistory();
        }

        function updateActionHistory() {
            actionHistoryDisplay.innerHTML = actionHistory.map(item =>
                `<div>${item.time.toLocaleTimeString()}: ${item.action} - ${item.speed.toFixed(0)}</div>`
            ).join('');
        }

        // Video Processing and Pose Detection
        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/${file}`
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        let camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });

        camera.start();
        console.log("Camera started")

        function onResults(results) {
            //if (!validateResults(results)) return;

            updateFPS();


            debugPanel.updateDOM(); // Probably shouldn't do this every frame


            drawVideoFrame(results);




            for (const [name, config] of Object.entries(landmarkConfig)) {
                if (config.index !== undefined) {  // Only process landmarks with defined indices
                    if (landmarkConfig[name]) {
                        if (results.poseLandmarks === undefined) continue;
                        // Could add a warning if no landmarks are visible
                        const landmark = results.poseLandmarks[config.index];
                        if (landmark.visibility < 0.75) continue;

                        // These are the only landmarks we use for most of the calculations. HOWEVER the drawVideoFrame function can draw all
                        // landmarks which makes it easier to debug.
                        // calculateSpeed is stateful since it does smoothing and anomaly detection
                        const speed = calculateSpeed(landmark, name);

                        // // Send the landmark to the debug display with the speed data
                        // let calibrationName = ''
                        // if (name === 'nose') {
                        //     calibrationName = 'jump'
                        //     // TODO During calibration, we know if it's a jump or a squat from the gameStep
                        //     // Later on 
                        // } 


                        // This manages the game state. Sets the calibration step, attempts, practice mode, or game mode. 

                        updateGameState();
                        if (gameState.phase == 'start' && (name == "leftWrist" || name == "rightWrist" || name == "nose")) {
                            // For the wrist landmarks, we can display debug data right away 
                            // For the nose, we need to know if it is a squat or a jump, which requires calibration
                            // to be complete
                            displayName = name;
                            if (displayName === "nose") displayName = "jump";
                            debugPanel.setActionData(displayName, { speed: speed });
                        }
                        else if (gameState.phase === 'calibration' && (name == gameState.step || name == 'nose' && gameState.step == 'jump' || name == 'nose' && gameState.step == 'squat')) {
                            // Update the actual calibration data. 
                            updateCalibration(landmark, speed);
                            updateCalibrationDisplay(); // This call does not seem to be working right now. Separate call in updateGameStep needed. Why?
                        } else if (gameState.phase === 'practice') {
                            updatePractice(name, landmark, speed);
                        } else if (gameState.phase === 'game') {
                            processLandmark(landmark, name, speed);
                        }

                    }
                }
            }
            gameState.frameCount++;
        }

        // This should be the only place the game state machine is updated. 
        function updateGameState() {
            switch (gameState.phase) {
                case 'start': break; // User has to click to start 
                case 'calibration':
                    switch (gameState.step) {
                        case 'leftWrist':
                            if (gameState.attempts.length > 0 && (performance.now() - gameState.lastAttemptTime) < CONFIG.WAIT_TIME) {
                                gameState.waitForCalibration = true;
                            } else if (gameState.attempts.length === CONFIG.CALIBRATION_ATTEMPTS) {
                                gameState.waitForCalibration = false;
                                finishCalibrationStep();
                                gameState.step = 'rightWrist';
                                gameState.attempts = [];
                                gameState.lastAttemptTime = 0;
                                gameState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };
                                updateCalibrationDisplay();
                            } else {
                                gameState.waitForCalibration = false;
                            }
                            break;
                        case 'rightWrist':
                            if (gameState.attempts.length > 0 && (performance.now() - gameState.lastAttemptTime) < CONFIG.WAIT_TIME) {
                                gameState.waitForCalibration = true;
                            } else if (gameState.attempts.length === CONFIG.CALIBRATION_ATTEMPTS) {
                                gameState.waitForCalibration = false;
                                finishCalibrationStep();
                                gameState.step = 'jump';
                                gameState.attempts = [];
                                gameState.lastAttemptTime = 0;
                                gameState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };
                                updateCalibrationDisplay();
                            } else {
                                gameState.waitForCalibration = false;
                            }
                            break;
                        case 'jump':
                            if (gameState.attempts.length > 0 && (performance.now() - gameState.lastAttemptTime) < CONFIG.WAIT_TIME) {
                                gameState.waitForCalibration = true;
                            } else if (gameState.attempts.length === CONFIG.CALIBRATION_ATTEMPTS) {
                                gameState.waitForCalibration = false;
                                finishCalibrationStep();
                                gameState.step = 'squat';
                                gameState.attempts = [];
                                gameState.lastAttemptTime = 0;
                                gameState.currentAttemptData = { maxSpeed: 0, startTime: 0, maxY: 0, minY: 1 };
                                updateCalibrationDisplay();
                            } else {
                                gameState.waitForCalibration = false;
                                // In the middle of an attempt we do nothing
                            }
                            break;
                        case 'squat':
                            if (gameState.attempts.length > 0 && (performance.now() - gameState.lastAttemptTime) < CONFIG.WAIT_TIME) {
                                gameState.waitForCalibration = true;
                            } else if (gameState.attempts.length === CONFIG.CALIBRATION_ATTEMPTS) {
                                gameState.phase = 'game'; // Add a countdown here
                                gameState.step = '';
                                gameState.attempts = [];
                                gameState.lastAttemptTime = 0;
                                document.getElementById('videoCanvas').style.display = 'none';
                                document.getElementById('gameCanvas').style.display = 'block';
                                document.getElementById('startGame').style.display = 'none';
                                isGameRunning = true;
                                updateCalibrationDisplay();
                                resetGameState();
                                gameLoop();
                            } else {
                                gameState.waitForCalibration = false;
                                // In the middle of an attempt we do nothing
                            }
                            break;
                    }
                    break;
                case 'practice': break;
                case 'game': break;
            }
        }

        function validateResults(results) {
            if (!results.poseLandmarks || results.poseLandmarks.length < 17) {
                handleErrorState(1, "Pose landmarks not detected");
                return false;
            }

            const requiredLandmarks = [0, 11, 12, 13, 14, 15, 16].map(i => results.poseLandmarks[i]);
            if (!areLandmarksVisible(requiredLandmarks)) {
                handleErrorState(2, "Please step back");
                return false;
            }

            return true;
        }

        function areLandmarksVisible(landmarks) {
            return landmarks.every(landmark => landmark && landmark.visibility > 0.75);
        }

        function processLandmark(landmark, name, speed) {
            if (name === 'nose') {
                const y = landmark.y;
                if (y < calibrationData.jump.minY && speed > calibrationData.jump.threshold * 0.8) {
                    debounceInput('h'); // Jump
                    console.log("JUMP", speed, calibrationData.jump.threshold)
                    debugPanel.setActionData('jump', {
                        speed: speed
                    });
                    return true;
                } else if (y > calibrationData.squat.maxY && speed > calibrationData.squat.threshold * 0.8) {
                    console.log("SQUAT", speed, calibrationData.squat.threshold)
                    debugPanel.setActionData('squat', {
                        speed: speed
                    });
                    debounceInput('u'); // Squat
                }
            } else {
                const threshold = calibrationData[name].threshold;
                if (speed > threshold * 0.8) {
                    console.log("LEFT OR RIGHT", speed, threshold * 0.8)
                    debounceInput(name === 'leftWrist' ? 'l' : 'r');
                }

                debugPanel.setActionData(name, {
                    speed: speed
                });
            }

            return false;
        }


        // *** SPEED CALCULATION SYSTEM
        // This keeps a short term history for motion smoothing and anomaly detection
        // It is conceptually a completely separate module from the rest of video capture. It doesn't even
        // know what game state is.

        // This is kinda messy. Globals used in calculating speed. Should put these somewhere better. 

        let lastPositions = {
            leftWrist: [],
            rightWrist: [],
            nose: []
        };

        let speedStats = {
            mean: 0,
            stdDev: 0,
            count: 0,
            lastFrame: 0
        };

        function updateSpeedStats(speed) {
            speedStats.count++;
            const delta = speed - speedStats.mean;
            speedStats.mean += delta / speedStats.count;
            speedStats.stdDev += delta * (speed - speedStats.mean);

            if (speedStats.count > 1) {
                speedStats.stdDev = Math.sqrt(speedStats.stdDev / (speedStats.count - 1));
            }
        }

        function isAnomaly(speed) {
            if (speedStats.count < 30) return false; // Wait for enough data
            return Math.abs(speed - speedStats.mean) > CONFIG.ANOMALY_MULTIPLIER * speedStats.stdDev;
        }

        function calculateSpeed(landmark, name, frame) {
            if (frame - speedStats.lastFrame > 100) return 0;

            const currentTime = performance.now();
            const currentPosition = { x: landmark.x, y: landmark.y, time: currentTime };

            if (lastPositions[name].length === 0) {
                lastPositions[name].push(currentPosition);
                return 0;
            }

            const history = lastPositions[name];
            const oldestPosition = history[0];
            const dt = (currentTime - oldestPosition.time) / 1000; // in seconds

            if (dt < CONFIG.MIN_TIME_THRESHOLD) return 0;

            const dx = currentPosition.x - oldestPosition.x;
            const dy = currentPosition.y - oldestPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < CONFIG.MIN_MOVEMENT_THRESHOLD || distance > CONFIG.MAX_MOVEMENT_THRESHOLD) {
                return 0;
            }

            const speed = distance / dt;
            const scaledSpeed = speed * videoCanvas.width;

            updateSpeedStats(scaledSpeed);

            // Update history
            history.push(currentPosition);
            if (history.length > CONFIG.HISTORY_SIZE) {
                history.shift();
            }

            return scaledSpeed;
        }

        let smoothedSpeeds = {};

        function getSmoothedSpeed(name, currentSpeed) {
            if (!(name in smoothedSpeeds)) {
                smoothedSpeeds[name] = currentSpeed;
            } else {
                smoothedSpeeds[name] = EMA_ALPHA * currentSpeed + (1 - EMA_ALPHA) * smoothedSpeeds[name];
            }
            return smoothedSpeeds[name];
        }

        function updateEMAAlpha() {
            EMA_ALPHA = 1 / CONFIG.SMOOTHING_LEVEL;
        }






        function drawVideoFrame(results) {
            videoCtx.save();
            videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoCtx.drawImage(results.image, 0, 0, videoCanvas.width, videoCanvas.height);

            if (results.poseLandmarks) {
                drawConnectors(videoCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 4 });
                drawLandmarks(videoCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 2 });
            }

            videoCtx.restore();
        }

        function updateFPS() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTimestamp;
            lastTimestamp = currentTime;

            fps = 1000 / deltaTime;
            fpsHistory.push(fps);
            if (fpsHistory.length > FPS_AVERAGE_COUNT) {
                fpsHistory.shift();
            }

            const averageFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;

            // Update the DOM every 100 frames only
            if (gameState.frameCount % 100 == 1) {
                fpsDisplay.textContent = `FPS: ${averageFps.toFixed(1)}`;
            }
        }

        function handleErrorState(status, message) {
            alertDisplay.textContent = message;
        }

        function clearErrorState() {
            alertDisplay.textContent = '';
        }

        // Event Listeners
        document.getElementById('startCalibration').addEventListener('click', startCalibration);
        document.getElementById('restartCalibration').addEventListener('click', startCalibration);
        document.getElementById('repeatStep').addEventListener('click', () => {
            if (gameState.phase === 'practice') {
                gameState.startTime = performance.now();
                updatePracticeDisplay();
            }
        });
        document.getElementById('startGame').addEventListener('click', () => {
            gameState.phase = 'game';
            document.getElementById('videoCanvas').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('startGame').style.display = 'none';
            isGameRunning = true;
            resetGameState();
            gameLoop();
        });



        // ----------------------------------------
        // ######      GAME COMPONENTS       ######
        // ----------------------------------------

        // The game is completely decoupled from the video processing. It just takes 
        // control inputs, as if you were using arrow keys on a keyboard. This is a 
        // pretty generic Tetris-like game implemented in WebGL. You can use it with
        // any other input device pretty easily. Keyboard controls also work just fine.

        // TODO: There is a flashing animation when a hard drop occurs, and a sliding 
        // animation whenever a row is eliminated. Neither work very well.

        // TODO: There is a hook for sound effects but none are implemented yet. 

        // Game configuration
        const COLUMNS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const DROP_INTERVAL = 4000; // Milliseconds between automatic drops

        // Game state
        let gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
        let currentPiece;
        let score = 0;
        let animatingRows = [];
        let animationStartTime = 0;
        let animationState = 'none';
        let slidingBlocks = [];
        let lastTime = 0;
        let dropCounter = 0;

        // Tetromino shapes and colors
        const SHAPES = [
            [[1, 1, 1, 1]],          // I
            [[1, 1], [1, 1]],        // O
            [[1, 1, 1], [0, 1, 0]],    // T
            [[1, 1, 1], [1, 0, 0]],    // L
            [[1, 1, 1], [0, 0, 1]],    // J
            [[1, 1, 0], [0, 1, 1]],    // S
            [[0, 1, 1], [1, 1, 0]]     // Z
        ];
        const COLORS = [
            [1, 0, 0, 1],    // Red
            [0, 1, 0, 1],    // Green
            [0, 0, 1, 1],    // Blue
            [1, 1, 0, 1],    // Yellow
            [1, 0, 1, 1],    // Magenta
            [0, 1, 1, 1],    // Cyan
            [1, .5, 0, 1]    // Orange
        ];

        // Initialize WebGL
        const canvas = document.getElementById('gameCanvas');

        // Input handling
        // TODO: Replace this with your custom input device logic
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowLeft': latestInput = 'l'; break;
                case 'ArrowRight': latestInput = 'r'; break;
                case 'ArrowDown': latestInput = 'd'; break;
                case 'ArrowUp': latestInput = 'u'; break;
                case ' ': latestInput = 'h'; break; // 'h' for hard drop
            }
        });

        // WebGL helper functions
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Shader source code
        const vertexShaderSource = `
            precision mediump float;
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            uniform vec2 u_resolution;
            varying vec2 v_texCoord;
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            uniform vec2 u_resolution;
            uniform float u_flash;
            varying vec2 v_texCoord;
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution;
                vec3 bgColor = mix(vec3(0.1, 0.1, 0.2), vec3(0.2, 0.2, 0.3), st.y);
                vec4 color = u_color;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(v_texCoord, center);
                color.rgb *= 0.8 + 0.2 * smoothstep(0.5, 0.0, dist);
                color.rgb += 0.1 * (1.0 - dist);
                float border = smoothstep(0.05, 0.07, min(min(v_texCoord.x, 1.0 - v_texCoord.x), min(v_texCoord.y, 1.0 - v_texCoord.y)));
                color.rgb *= 0.8 + 0.2 * border;
                vec3 flashColor = mix(mix(bgColor, color.rgb, color.a), vec3(1.0), u_flash);
                gl_FragColor = vec4(flashColor, 1.0);
            }
        `;

        // Create and set up WebGL program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        if (!program) {
            console.error('Failed to create shader program');
        } else {
            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const flashLocation = gl.getUniformLocation(program, "u_flash");
            const positionBuffer = gl.createBuffer();
            const texCoordBuffer = gl.createBuffer();

            // Resize canvas to fit the game field
            function resizeCanvas() {
                canvas.width = COLUMNS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Draw a rectangle (used for blocks and grid lines)
            function drawRectangle(x, y, width, height, color, flash = 0) {
                const yFlipped = canvas.height - y - height; // Flip y-coordinate for OpenGL
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, yFlipped, x + width, yFlipped, x, yFlipped + height, x, yFlipped + height, x + width, yFlipped, x + width, yFlipped + height]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(positionLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(texCoordLocation);

                gl.uniform4fv(colorLocation, color);
                gl.uniform1f(flashLocation, flash);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Draw the game field
            function drawField(flash = 0) {
                drawRectangle(0, 0, canvas.width, canvas.height, [0, 0, 0, 0], flash);
                for (let x = 0; x <= COLUMNS; x++) drawRectangle(x * BLOCK_SIZE - 1, 0, 2, canvas.height, [1, 1, 1, 0.2], flash);
                for (let y = 0; y <= ROWS; y++) drawRectangle(0, y * BLOCK_SIZE - 1, canvas.width, 2, [1, 1, 1, 0.2], flash);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLUMNS; x++) {
                        if (gameField[y][x] !== -1) {
                            let color = COLORS[gameField[y][x]];
                            let yPos = y;
                            if (animationState === 'sliding') {
                                const block = slidingBlocks.find(b => b.x === x && b.destY === y);
                                if (block) {
                                    const progress = (Date.now() - animationStartTime) / 500;
                                    yPos = block.startY + (y - block.startY) * progress;
                                }
                            }
                            drawRectangle(x * BLOCK_SIZE, yPos * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    }
                }
            }

            // Draw the current piece
            function drawPiece(flash = 0) {
                if (!currentPiece) return;
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            let color = COLORS[currentPiece.color];
                            drawRectangle((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    });
                });
            }

            // Create a new piece
            function createNewPiece() {
                const shapeIndex = Math.floor(Math.random() * SHAPES.length);
                return {
                    shape: SHAPES[shapeIndex],
                    x: Math.floor(COLUMNS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),
                    y: 0,
                    color: shapeIndex
                };
            }

            // Check for collisions
            function checkCollision() {
                return currentPiece.shape.some((row, y) => row.some((value, x) =>
                    value && (
                        y + currentPiece.y >= ROWS ||
                        x + currentPiece.x < 0 ||
                        x + currentPiece.x >= COLUMNS ||
                        (gameField[y + currentPiece.y] && gameField[y + currentPiece.y][x + currentPiece.x] !== -1)
                    )
                ));
            }

            // Rotate the current piece
            function rotatePiece() {
                const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
                const previousShape = currentPiece.shape;
                currentPiece.shape = rotated;
                if (checkCollision()) currentPiece.shape = previousShape;
            }

            // Move the current piece down
            function moveDown() {
                if (animationState !== 'none') return;
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    freezePiece();
                    checkLines();
                    if (animatingRows.length === 0) {
                        currentPiece = createNewPiece();
                        if (checkCollision()) {
                            // Game over
                            gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                            score = 0;
                            playSound('gameOver');
                        }
                    }
                }
            }

            // Freeze the current piece in place
            function freezePiece() {
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            gameField[y + currentPiece.y][x + currentPiece.x] = currentPiece.color;
                        }
                    });
                });
                playSound('pieceLand');
            }

            // Check for completed lines
            function checkLines() {
                animatingRows = [];
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (gameField[y].every(cell => cell !== -1)) animatingRows.push(y);
                }
                if (animatingRows.length > 0) {
                    animationState = 'sliding';
                    animationStartTime = Date.now();
                    slidingBlocks = [];
                    let rowsCleared = 0;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (animatingRows.includes(y)) {
                            rowsCleared++;
                        } else if (rowsCleared > 0) {
                            for (let x = 0; x < COLUMNS; x++) {
                                if (gameField[y][x] !== -1) {
                                    slidingBlocks.push({ x, startY: y, destY: y + rowsCleared });
                                }
                            }
                        }
                    }
                    playSound('lineCleared');
                }
            }

            // Update animation state
            function updateAnimation(deltaTime) {
                if (animationState === 'sliding' && Date.now() - animationStartTime > 500) {
                    animatingRows.sort((a, b) => b - a).forEach(y => {
                        gameField.splice(y, 1);
                        gameField.unshift(Array(COLUMNS).fill(-1));
                    });
                    slidingBlocks.forEach(block => {
                        gameField[block.destY][block.x] = gameField[block.startY][block.x];
                        gameField[block.startY][block.x] = -1;
                    });
                    score += animatingRows.length * 100;
                    animatingRows = [];
                    slidingBlocks = [];
                    animationState = 'none';
                    currentPiece = createNewPiece();
                }
            }

            // Perform a hard drop
            function hardDrop() {
                while (!checkCollision()) {
                    currentPiece.y++;
                }
                currentPiece.y--;
                freezePiece();
                checkLines();
                if (animatingRows.length === 0) {
                    currentPiece = createNewPiece();
                    if (checkCollision()) {
                        gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                        score = 0;
                    }
                }
                flashScreen();
                //playSoundEffect(audioFall)
            }

            // Flash the screen (for hard drop)
            let flashIntensity = 0;
            function flashScreen() {
                flashIntensity = 1;
            }

            // Handle input
            function handleInput() {
                if (animationState !== 'none') return;
                switch (latestInput) {
                    case 'l':
                        currentPiece.x--;
                        //playSoundEffect(audioLeft) // TODO don't play if collission
                        if (checkCollision()) {
                            currentPiece.x++;
                        }
                        break;
                    case 'r':
                        currentPiece.x++;
                        //playSoundEffect(audioRight) // TODO don't play if collission

                        if (checkCollision()) {
                            currentPiece.x--;
                        }
                        break;
                    case 'd':
                        moveDown();
                        break;
                    case 'u':
                        rotatePiece();
                        break;
                    case 'h':
                        hardDrop();
                        break;
                }
                latestInput = null; // Reset input after handling
            }

            // Play sound effects
            function playSound(action) {
                // TODO: Implement sound playback
                console.log(`Playing sound for: ${action}`);
            }

            function playSoundEffect(sound) {
                sound.currentTime = 0;
                sound.playSound();
            }

            // Update game state
            function update(deltaTime) {
                handleInput();
                dropCounter += deltaTime;
                if (dropCounter > DROP_INTERVAL) {
                    moveDown();
                    dropCounter = 0;
                }
                updateAnimation(deltaTime);
                if (flashIntensity > 0) {
                    flashIntensity = Math.max(0, flashIntensity - deltaTime / 100);
                }
            }

            function resetGameState() {
                gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                score = 0;
                currentPiece = createNewPiece();
                animatingRows = [];
                animationState = 'none';
                slidingBlocks = [];
                dropCounter = 0;
                actionHistory = [];
                //updateActionHistory(); not sure
            }

            // Main game loop
            function gameLoop(currentTime = 0) {
                if (!isGameRunning) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(deltaTime);

                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

                drawField(flashIntensity);
                drawPiece(flashIntensity);

                scoreElement.textContent = `Score: ${score}`;

                requestAnimationFrame(gameLoop);
            }

            // Start the game
            currentPiece = createNewPiece();
            gameLoop();
        }
    </script>
</body>

</html>