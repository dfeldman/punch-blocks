<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Punch Blocks</title>
    <style>
body {
    margin: 0;
    overflow: hidden;
    background: linear-gradient(135deg, #1a1a2e, #0f0f1a);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: Arial, sans-serif;
    color: #b9a6ff;
}

#score {
    position: absolute;
    top: 20px;
    left: 20px;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}

#controls {
    position: absolute;
    top: 100px;
    left: 20px;
    display: flex;
    flex-direction: column;
}

#fps  {
    position: absolute;
    top: 20px;
    right: 20px;
    text-align: right;
    font-size: 18px;
}


#alert {
    display: block;
    position: absolute;
    top: 100px;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: #f99797;
}

#tutorial {
    display: block;
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    color: white;
}


#restartTutorial {
    position: relative;
    font-size: 14px;
    padding: 10px 20px;
    margin: 5px;
    background: #b9a6ff;
    color: #1a1a2e;
    border: none;
    cursor: pointer;
}

#startGame {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 32px;
    padding: 10px 20px;
    background: #b9a6ff;
    color: #1a1a2e;
    border: none;
    cursor: pointer;
}

canvas {
    display: none;
    margin: auto;
}

#videoCanvas {
    position: absolute;
    display: block;
    max-width: 640px;
    max-height: 480px;
    width: 100%;
    height: auto;
}
#gameCanvas {
    position: absolute;
    top: 150px;
    height: 80vh; /* Set the height to 100% of the viewport height */
    width: 40vh;   /* Set the width to 40% of the viewport height to maintain the aspect ratio */
    border: 5px solid #b9a6ff; /* Add a cool border */
    border-radius: 10px; /* Optional: Add rounded corners to the border */
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); /* Optional: Add a shadow for a cool effect */
    margin: 10px;
}

#info {
    position: absolute;
    top: 20px;
    right: 20px;
    text-align: right;
    font-size: 18px;
}

    </style>
</head>
<body>
    <div id="controls">
        <label for="smoothing">Smoothing Level:</label>
        <input type="range" id="smoothing" name="smoothing" min="1" max="10" value="1">
        <label for="speedThreshold">Punch Speed Threshold:</label>
        <input type="range" id="speedThreshold" name="speedThreshold" min="1" max="100" value="5">
        <label for="slowSpeedThreshold">Squat/Jump Speed Threshold:</label>
        <input type="range" id="slowSpeedThreshold" name="slowSpeedThreshold" min="1" max="100" value="5">
        <label for="jumpThreshold">Jump Height Threshold (%):</label>
        <input type="range" id="jumpThreshold" name="jumpThreshold" min="1" max="100" value="30">
        <label for="squatThreshold">Squat Height Threshold (%):</label>
        <input type="range" id="squatThreshold" name="squatThreshold" min="1" max="100" value="70">
        <label for="squatThreshold">Min Distance:</label>
        <input type="range" id="minDistance" name="minDistance" min="1" max="100" value="3">
        <label for="squatThreshold">Debounce Frames</label>
        <input type="range" id="debounceFrames" name="debounceFrames" min="1" max="10" value="2">
        <button id="restartTutorial">Restart Tutorial</button>

    </div>
    <div id="info">
        <div id="fps">FPS: 0</div>

    </div>
    <div id="alert"></div>
    <div id="tutorial">Enable your camera</div>
    <canvas id="videoCanvas" width="640" height="480"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>

    <button id="startGame">Start Game</button>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  
    <script>


        // TODO 
        // Figure out the NaN issue
        // Add sounds
        // Jump needs to be a hard drop
        // Display the motion with an icon
        // Set scoring: give lots of points for motion
        // Add a timer
        // Add a game over screen
        // Add a start screen
        // Add a pause screen





        // This is really two separate real-time processing loops that are interleaved.
        // One is for video, and the other is for the game.
        // They only communicate through a few shared global variables. 

        // ----------------------------------------
        // ######      VIDEO COMPONENTS      ######
        // ----------------------------------------
        // The video processing code uses MediaPipe from Google to do pose recognition. 
        // Its input is a few config options. 
        // Its output is a status, positions, and an input to the game. 
        // Input may be "l", "r", "d", "h", "u". 
        // Status may be "OK" (everything is working), "BACKUP" (can't see necessary landmarks)
        // Positions are x/y positions for the left hand, head, and right hand for user feedback.
        // and more to be added later. 

        // Initialize MediaPipe Pose
        // A hidden video element is used for MediaPipe only.
        // This is different from videoCanvas which is used for user feedback.
        const videoElement = document.createElement('video');
        videoElement.style.display = 'none';
        document.body.appendChild(videoElement);


        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');
        const gameCanvas = document.getElementById('gameCanvas');
        const gl = gameCanvas.getContext('webgl');
        const scoreElement = document.getElementById('score');
        const fpsDisplay = document.getElementById('fps');
        const alertDisplay = document.getElementById('alert');
        const tutorialDisplay = document.getElementById('tutorial');

        let isGameRunning = false;
        let lastTimestamp = performance.now();
        let fps = 0;
        let fpsHistory = [];
        const FPS_AVERAGE_COUNT = 10;

        let smoothingLevel = 1;
        let speedThreshold = 5;
        let slowSpeedThreshold = 5;

        let jumpThreshold = 0.7;
        let squatThreshold = 0.7;

        let headPositions = [];
        let leftWristPositions = [];
        let rightWristPositions = [];

        let debounceFrames = 4; // Number of frames to maintain the input before it's considered valid
        let minDistance = 0.03; // Arm movements less than this are ignored

        let tutorialStep = 0;

        // -1 = not started, 0 = running, 1 = no landmarks, 2 = too close
        let videoErrorStatus = -1;

        // This is the key global variable that controls the entire game.
        // After video processing and debouncing, this gets set to the latest input action. 
        // After processing the input, it set back to null. 
        // 'n' means no action, which can be used for debugging. null means whatever action has been proceesed. 
        let latestInput = null;

        // Tutorial text strings
        const tutorialText = [
            // Perhaps add a step 0 to turn on the camera
            "Stand back from the camera",
            "Punch left to move the block left",
            "Punch right to move the block right",
            "Squat to rotate the block",
            "Jump to quick drop the block",
            "Get ready to play!"];

        const inputToText = {
            'l': 'Punch left',
            'r': 'Punch right',
            'u': 'Jump',
            'h': 'Squat',
            'n': 'No action'
        };

        // Effects audio files
        var audioLeft = new Audio('assets/effects/left.mp3');
        var audioRight = new Audio('assets/effects/right.mp3');
        var audioFall = new Audio('assets/effects/fall.mp3');
        var audioRotate = new Audio('assets/effects/rotate.mp3');
        //var audioLand = new Audio('assets/effects/land.mp3'); // not used


        function playSoundEffect(audio) {
            audio.currentTime = 0;
            audio.play();
        }





        // Debounce system
        let debounceCounters = {
            'l': 0,
            'r': 0,
            'u': 0,
            'h': 0,
            'n': 0,
        };

        function resetDebounceCounters() {
            debounceCounters['l'] = 0;
            debounceCounters['r'] = 0;
            debounceCounters['u'] = 0;
            debounceCounters['h'] = 0;
            debounceCounters['n'] = 0;

        }

        function debounceInput(input) {
            let mult = 1;
            if (input) {
                debounceCounters[input]++;
                if (input === 'h') {
                    // Squatting and jumping gets 2x the debounce because it's a slower movement
                    mult = 2;
                } else if (input == 'u') {
                    mult = 2; // not sure
                }
                if (debounceCounters[input] >= (debounceFrames*mult)) {
                    //console.log("DEBOUNCE VALUE", input, debounceCounters[input])
                    sendInput(input);
                    resetDebounceCounters();
                }
            } else {
                //sendInput('n');
                resetDebounceCounters();
            }
        }

        function sendInput(input) {
            latestInput = input;
            //console.log("LATEST INPUT", inputToText[latestInput]);
            if (input != 'n') alertDisplay.textContent = inputToText[latestInput];
        }

        // tutorial display
        function updateTutorial() {
            if (tutorialStep >= 6) return;
            tutorialDisplay.textContent = tutorialText[tutorialStep];
            alertDisplay.textContent = ""; // Alert is turned off in tutorial mode

            switch (tutorialStep) {
                case 0:
                    if (videoErrorStatus === 0) {
                        tutorialStep++;
                    }
                    break;
                case 1:
                    if (latestInput === 'l') {
                        tutorialStep++;
                    }
                    latestInput = null;
                    break;
                case 2:
                    if (latestInput === 'r') {
                        tutorialStep++;
                    }
                    latestInput = null;
                    break;
                case 3:
                    if (latestInput === 'u') {
                        tutorialStep++;
                    }        
                    latestInput = null;            
                    break;
                case 4:
                    if (latestInput === 'h') {
                        tutorialStep++;
                    }                    
                    latestInput = null;
                    break;
                case 5:
                    // Display Start Game button and hide tutorial box
                    break;
            }
        }

        // Called each time there are results in from MediaPipe
        function onResults(results) {
            // Before doing anything, update the tutorial text based on the current state
            // This way, if we return early, it's already set
            updateTutorial();

            // Calculate FPS
            const currentTimestamp = performance.now();
            fps = 1000 / (currentTimestamp - lastTimestamp);
            fpsHistory.push(fps);
            if (fpsHistory.length > FPS_AVERAGE_COUNT) {
                fpsHistory.shift();
            }
            const averageFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
            fpsDisplay.textContent = `FPS: ${averageFps.toFixed(2)}`;

            lastTimestamp = currentTimestamp;

            // Clear canvas
            videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
            videoCtx.save();
            videoCtx.scale(-1, 1);
            videoCtx.translate(-videoCanvas.width, 0);
            videoCtx.drawImage(videoElement, 0, 0, videoCanvas.width, videoCanvas.height);
            videoCtx.restore();

            // Check if poseLandmarks exists and has the required landmarks
            if (!results.poseLandmarks || results.poseLandmarks.length < 17) {
                videoErrorStatus = 1;
                alertDisplay.textContent = "Pose landmarks not detected";
                return;
            }

            // Check if required landmarks are visible
            const landmarksToCheck = [
                results.poseLandmarks[0],  // Nose
                results.poseLandmarks[11], // Left shoulder
                results.poseLandmarks[12], // Right shoulder
                results.poseLandmarks[13], // Left elbow
                results.poseLandmarks[14], // Right elbow
                results.poseLandmarks[15], // Left wrist
                results.poseLandmarks[16]  // Right wrist
            ];

            if (!areLandmarksVisible(landmarksToCheck)) {
                // If the landmarks are not visible, show an alert
                // Except in tutorial where there is already an alert
                if (tutorialStep > 1) alertDisplay.textContent = "BACK UP";
                videoErrorStatus = 2;
            } else {
                alertDisplay.textContent = "";
                videoErrorStatus = 0;
            }
            // Even if the video has an error, still attempt to process some remainng points
            // Todo: I'm unsure about this. Certainly when squatting it's hard to keep the hands in view
            // But, if the hands are not in view, the game will be unplayable.
            // Process landmarks
            //console.log('Processing landmarks...');
            if (processLandmark(results.poseLandmarks[0], headPositions, 'blue', 'Head')) {
                return; // If the user is jumping, stop processing the rest of the landmarks
            } // Nose (head)
            processLandmark(results.poseLandmarks[15], leftWristPositions, 'red', 'Left Wrist'); // Left wrist
            processLandmark(results.poseLandmarks[16], rightWristPositions, 'green', 'Right Wrist'); // Right wrist
            
        }

        function areLandmarksVisible(landmarks) {
            return landmarks.every(landmark => landmark && landmark.visibility > 0.75);
        }

        function processLandmark(landmark, positionArray, color, name) {
            if (landmark && landmark.visibility > 0.75) {
                const currentTime = performance.now();
                positionArray.push({ x: landmark.x, y: landmark.y, time: currentTime });
                positionArray = positionArray.filter(pos => currentTime - pos.time <= smoothingLevel * 100);

                // Calculate the average position
                const avgPosition = positionArray.reduce((acc, pos) => ({
                    x: acc.x + pos.x,
                    y: acc.y + pos.y
                }), { x: 0, y: 0 });

                avgPosition.x /= positionArray.length;
                avgPosition.y /= positionArray.length;

                //console.log(`Drawing ${name} at (${avgPosition.x}, ${avgPosition.y}) with color ${color}`);

                // Draw the smoothed position
                drawCircle(avgPosition, color);

                // Calculate speed and determine action
                if (positionArray.length >= 2) {
                    const latestPos = positionArray[positionArray.length - 1];
                    const previousPos = positionArray[positionArray.length - 2];

                    const dx = latestPos.x - previousPos.x;
                    const dy = latestPos.y - previousPos.y;
                    const dt = (latestPos.time - previousPos.time) / 1000; // in seconds

                    const speed = (Math.sqrt(dx * dx + dy * dy) * videoCanvas.width / dt) * 100;

                    const distance = Math.sqrt(dx * dx + dy * dy);

                    //console.log(`${name} speed: ${speed.toFixed(2)} px/s`);

                    
                    // if (name === 'Left Wrist' && speed > speedThreshold) {
                    //     latestInput = 'l';
                    //     console.log('Punch Left');
                    // } else if (name === 'Right Wrist' && speed > speedThreshold) {
                    //     latestInput = 'r';
                    //     console.log('Punch Right');
                    // } else if (name === 'Head') {
                    //     if (avgPosition.y < squatThreshold) {
                    //         latestInput = 'd';
                    //         console.log('Squat');
                    //     } else if (avgPosition.y > jumpThreshold) {
                    //         latestInput = 'u';
                    //         console.log('Jump');
                    //     }
                    // }


                    // Send input to debouncer
                    // Debouncer puts it in latestInput which then goes to the game
                    let input = null;

                    if (name === 'Left Wrist' && speed > speedThreshold && distance > minDistance) {
                        input = 'l';

                    } else if (name === 'Right Wrist' && speed > speedThreshold && distance > minDistance) {
                        input = 'r';

                    } else if (name === 'Head') {
                        // These are reversed
                        if (avgPosition.y > squatThreshold && speed > slowSpeedThreshold) {
                            input = 'u';
                        // TODO jumping is really hard! You have to almost hover to get this to work
                        // Removed mimimum distance for jumping
                        // Hardcoded a 1.5x boost
                        // Stopped processing arm movements if the user is jumping
                        } else if (avgPosition.y < jumpThreshold && speed*1.5 > slowSpeedThreshold && distance > minDistance) {
                            input = 'h';

                            // Early return in the case of jumping only
                            // This is messy
                            debounceInput(input);
                            return true; 
                        } else {
                            input = 'n';
                        }
                    }

                    videoErrorStatus = 0;
                    debounceInput(input);
                }
            }
            return false;
        }

        // function drawCircle(position, color) {
        //     // Convert normalized coordinates (0-1) to canvas coordinates
        //     const x = position.x * videoCanvas.width;
        //     const y = position.y * videoCanvas.height;

        //     console.log(`drawCircle at (${x}, ${y}) with color ${color}`);
        //     //videoCtx.save(); // Save the current state
        //     videoCtx.beginPath();
        //     videoCtx.arc(x, y, 10, 0, 2 * Math.PI);
        //     videoCtx.fillStyle = color;
        //     videoCtx.fill();
        //     //videoCtx.restore(); // Restore the saved state
        // }

        // BUG this is getting called with NaN/NaN sometimes!!
        function drawCircle(position, color) {
            const x = (videoCanvas.width - (position.x * videoCanvas.width))
            const y = position.y * videoCanvas.height;
            //console.log("DRAW CIRCLE AT", x, y)
            videoCtx.save()
            videoCtx.beginPath();
            videoCtx.arc(x, y, 10, 0, 2 * Math.PI);
            videoCtx.fillStyle = color;
            videoCtx.fill();
            videoCtx.restore();
        }


        const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4/${file}`
        });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        pose.onResults(onResults);

        let camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({ image: videoElement });
            },
            width: 640,
            height: 480,
            facingMode: 'user'
        });
        camera.start();
        videoElement.style.display = 'none';
        // temp -- this is used to enable video display while playing
        document.getElementById('videoCanvas').style.display = 'block';


        document.getElementById('smoothing').addEventListener('input', (event) => {
            smoothingLevel = parseInt(event.target.value, 10);
        });

        document.getElementById('speedThreshold').addEventListener('input', (event) => {
            speedThreshold = parseInt(event.target.value, 10);
        });

        document.getElementById('slowSpeedThreshold').addEventListener('input', (event) => {
            slowSpeedThreshold = parseInt(event.target.value, 10);
        });

        document.getElementById('jumpThreshold').addEventListener('input', (event) => {
            jumpThreshold = parseInt(event.target.value, 10) / 100;
        });

        document.getElementById('squatThreshold').addEventListener('input', (event) => {
            squatThreshold = parseInt(event.target.value, 10) / 100;
        });


        document.getElementById('minDistance').addEventListener('input', (event) => {
            minDistance = parseInt(event.target.value, 10) / 100.0;
        });

        document.getElementById('debounceFrames').addEventListener('input', (event) => {
            debounceFrames = parseInt(event.target.value, 10);
        });

        document.getElementById('restartTutorial').addEventListener('click', () => {
            tutorialStep = 0;
            updateTutorial();
            isGameRunning = false;
            document.getElementById('videoCanvas').style.display = 'block';
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('startGame').style.display = 'block';
        });

        document.getElementById('startGame').addEventListener('click', () => {
            document.getElementById('videoCanvas').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('startGame').style.display = 'none';
            tutorialStep = 6; // Skip the tutorial if the user starts early
            tutorialDisplay.textContent = ""; // Don't want to change this inside the game loop
            isGameRunning = true;
            gameLoop();
        });




        // ----------------------------------------
        // ######      GAME COMPONENTS       ######
        // ----------------------------------------

        // The game is completely decoupled from the video processing. It just takes 
        // control inputs, as if you were using arrow keys on a keyboard. This is a 
        // pretty generic Tetris-like game implemented in WebGL. You can use it with
        // any other input device pretty easily. Keyboard controls also work just fine.

        // TODO: There is a flashing animation when a hard drop occurs, and a sliding 
        // animation whenever a row is eliminated. Neither work very well.

        // TODO: There is a hook for sound effects but none are implemented yet. 

        // Game configuration
        const COLUMNS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const DROP_INTERVAL = 4000; // Milliseconds between automatic drops

        // Game state
        let gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
        let currentPiece;
        let score = 0;
        let animatingRows = [];
        let animationStartTime = 0;
        let animationState = 'none';
        let slidingBlocks = [];
        let lastTime = 0;
        let dropCounter = 0;

        // Tetromino shapes and colors
        const SHAPES = [
            [[1,1,1,1]],          // I
            [[1,1],[1,1]],        // O
            [[1,1,1],[0,1,0]],    // T
            [[1,1,1],[1,0,0]],    // L
            [[1,1,1],[0,0,1]],    // J
            [[1,1,0],[0,1,1]],    // S
            [[0,1,1],[1,1,0]]     // Z
        ];
        const COLORS = [
            [1,0,0,1],    // Red
            [0,1,0,1],    // Green
            [0,0,1,1],    // Blue
            [1,1,0,1],    // Yellow
            [1,0,1,1],    // Magenta
            [0,1,1,1],    // Cyan
            [1,.5,0,1]    // Orange
        ];

        // Initialize WebGL
        const canvas = document.getElementById('gameCanvas');

        // Input handling
        // TODO: Replace this with your custom input device logic
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowLeft': latestInput = 'l'; break;
                case 'ArrowRight': latestInput = 'r'; break;
                case 'ArrowDown': latestInput = 'd'; break;
                case 'ArrowUp': latestInput = 'u'; break;
                case ' ': latestInput = 'h'; break; // 'h' for hard drop
            }
        });

        // WebGL helper functions
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Shader source code
        const vertexShaderSource = `
            precision mediump float;
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            uniform vec2 u_resolution;
            varying vec2 v_texCoord;
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform vec4 u_color;
            uniform vec2 u_resolution;
            uniform float u_flash;
            varying vec2 v_texCoord;
            void main() {
                vec2 st = gl_FragCoord.xy / u_resolution;
                vec3 bgColor = mix(vec3(0.1, 0.1, 0.2), vec3(0.2, 0.2, 0.3), st.y);
                vec4 color = u_color;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(v_texCoord, center);
                color.rgb *= 0.8 + 0.2 * smoothstep(0.5, 0.0, dist);
                color.rgb += 0.1 * (1.0 - dist);
                float border = smoothstep(0.05, 0.07, min(min(v_texCoord.x, 1.0 - v_texCoord.x), min(v_texCoord.y, 1.0 - v_texCoord.y)));
                color.rgb *= 0.8 + 0.2 * border;
                vec3 flashColor = mix(mix(bgColor, color.rgb, color.a), vec3(1.0), u_flash);
                gl_FragColor = vec4(flashColor, 1.0);
            }
        `;

        // Create and set up WebGL program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        if (!program) {
            console.error('Failed to create shader program');
        } else {
            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const flashLocation = gl.getUniformLocation(program, "u_flash");
            const positionBuffer = gl.createBuffer();
            const texCoordBuffer = gl.createBuffer();

            // Resize canvas to fit the game field
            function resizeCanvas() {
                canvas.width = COLUMNS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Draw a rectangle (used for blocks and grid lines)
            function drawRectangle(x, y, width, height, color, flash = 0) {
                const yFlipped = canvas.height - y - height; // Flip y-coordinate for OpenGL
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x,yFlipped,x+width,yFlipped,x,yFlipped+height,x,yFlipped+height,x+width,yFlipped,x+width,yFlipped+height]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(positionLocation);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]), gl.STATIC_DRAW);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(texCoordLocation);

                gl.uniform4fv(colorLocation, color);
                gl.uniform1f(flashLocation, flash);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Draw the game field
            function drawField(flash = 0) {
                drawRectangle(0, 0, canvas.width, canvas.height, [0,0,0,0], flash);
                for (let x = 0; x <= COLUMNS; x++) drawRectangle(x * BLOCK_SIZE - 1, 0, 2, canvas.height, [1,1,1,0.2], flash);
                for (let y = 0; y <= ROWS; y++) drawRectangle(0, y * BLOCK_SIZE - 1, canvas.width, 2, [1,1,1,0.2], flash);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLUMNS; x++) {
                        if (gameField[y][x] !== -1) {
                            let color = COLORS[gameField[y][x]];
                            let yPos = y;
                            if (animationState === 'sliding') {
                                const block = slidingBlocks.find(b => b.x === x && b.destY === y);
                                if (block) {
                                    const progress = (Date.now() - animationStartTime) / 500;
                                    yPos = block.startY + (y - block.startY) * progress;
                                }
                            }
                            drawRectangle(x * BLOCK_SIZE, yPos * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    }
                }
            }

            // Draw the current piece
            function drawPiece(flash = 0) {
                if (!currentPiece) return;
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            let color = COLORS[currentPiece.color];
                            drawRectangle((currentPiece.x + x) * BLOCK_SIZE, (currentPiece.y + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE, color, flash);
                        }
                    });
                });
            }

            // Create a new piece
            function createNewPiece() {
                const shapeIndex = Math.floor(Math.random() * SHAPES.length);
                return {
                    shape: SHAPES[shapeIndex],
                    x: Math.floor(COLUMNS / 2) - Math.floor(SHAPES[shapeIndex][0].length / 2),
                    y: 0,
                    color: shapeIndex
                };
            }

            // Check for collisions
            function checkCollision() {
                return currentPiece.shape.some((row, y) => row.some((value, x) => 
                    value && (
                        y + currentPiece.y >= ROWS ||
                        x + currentPiece.x < 0 || 
                        x + currentPiece.x >= COLUMNS ||
                        (gameField[y + currentPiece.y] && gameField[y + currentPiece.y][x + currentPiece.x] !== -1)
                    )
                ));
            }

            // Rotate the current piece
            function rotatePiece() {
                const rotated = currentPiece.shape[0].map((_, i) => currentPiece.shape.map(row => row[i]).reverse());
                const previousShape = currentPiece.shape;
                currentPiece.shape = rotated;
                if (checkCollision()) currentPiece.shape = previousShape;
            }

            // Move the current piece down
            function moveDown() {
                if (animationState !== 'none') return;
                currentPiece.y++;
                if (checkCollision()) {
                    currentPiece.y--;
                    freezePiece();
                    checkLines();
                    if (animatingRows.length === 0) {
                        currentPiece = createNewPiece();
                        if (checkCollision()) {
                            // Game over
                            gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                            score = 0;
                            playSound('gameOver');
                        }
                    }
                }
            }

            // Freeze the current piece in place
            function freezePiece() {
                currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            gameField[y + currentPiece.y][x + currentPiece.x] = currentPiece.color;
                        }
                    });
                });
                playSound('pieceLand');
            }

            // Check for completed lines
            function checkLines() {
                animatingRows = [];
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (gameField[y].every(cell => cell !== -1)) animatingRows.push(y);
                }
                if (animatingRows.length > 0) {
                    animationState = 'sliding';
                    animationStartTime = Date.now();
                    slidingBlocks = [];
                    let rowsCleared = 0;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (animatingRows.includes(y)) {
                            rowsCleared++;
                        } else if (rowsCleared > 0) {
                            for (let x = 0; x < COLUMNS; x++) {
                                if (gameField[y][x] !== -1) {
                                    slidingBlocks.push({x, startY: y, destY: y + rowsCleared});
                                }
                            }
                        }
                    }
                    playSound('lineCleared');
                }
            }

            // Update animation state
            function updateAnimation(deltaTime) {
                if (animationState === 'sliding' && Date.now() - animationStartTime > 500) {
                    animatingRows.sort((a, b) => b - a).forEach(y => {
                        gameField.splice(y, 1);
                        gameField.unshift(Array(COLUMNS).fill(-1));
                    });
                    slidingBlocks.forEach(block => {
                        gameField[block.destY][block.x] = gameField[block.startY][block.x];
                        gameField[block.startY][block.x] = -1;
                    });
                    score += animatingRows.length * 100;
                    animatingRows = [];
                    slidingBlocks = [];
                    animationState = 'none';
                    currentPiece = createNewPiece();
                }
            }

            // Perform a hard drop
            function hardDrop() {
                while (!checkCollision()) {
                    currentPiece.y++;
                }
                currentPiece.y--;
                freezePiece();
                checkLines();
                if (animatingRows.length === 0) {
                    currentPiece = createNewPiece();
                    if (checkCollision()) {
                        gameField = Array(ROWS).fill().map(() => Array(COLUMNS).fill(-1));
                        score = 0;
                    }
                }
                flashScreen();
                playSoundEffect(audioFall)
            }

            // Flash the screen (for hard drop)
            let flashIntensity = 0;
            function flashScreen() {
                flashIntensity = 1;
            }

            // Handle input
            function handleInput() {
                if (animationState !== 'none') return;
                switch (latestInput) {
                    case 'l': 
                        currentPiece.x--;
                        playSoundEffect(audioLeft) // TODO don't play if collission
                        if (checkCollision()) {
                            currentPiece.x++;
                        }
                        break;
                    case 'r':
                        currentPiece.x++;
                        playSoundEffect(audioRight) // TODO don't play if collission

                        if (checkCollision()) {
                            currentPiece.x--;
                        }
                        break;
                    case 'd':
                        moveDown();
                        break;
                    case 'u':
                        rotatePiece();
                        break;
                    case 'h':
                        hardDrop();
                        break;
                }
                latestInput = null; // Reset input after handling
            }

            // Play sound effects
            function playSound(action) {
                // TODO: Implement sound playback
                console.log(`Playing sound for: ${action}`);
            }

            // Update game state
            function update(deltaTime) {
                handleInput();
                dropCounter += deltaTime;
                if (dropCounter > DROP_INTERVAL) {
                    moveDown();
                    dropCounter = 0;
                }
                updateAnimation(deltaTime);
                if (flashIntensity > 0) {
                    flashIntensity = Math.max(0, flashIntensity - deltaTime / 100);
                }
            }

            // Main game loop
            function gameLoop(currentTime = 0) {
                if (!isGameRunning) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(deltaTime);

                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                
                drawField(flashIntensity);
                drawPiece(flashIntensity);
                
                scoreElement.textContent = `Score: ${score}`;

                requestAnimationFrame(gameLoop);
            }

            // Start the game
            currentPiece = createNewPiece();
            gameLoop();
        }
    </script>
</body>
</html>